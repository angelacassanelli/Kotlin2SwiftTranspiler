from antlr4 import *

class KotlinToSwiftTransformer(ParseTreeVisitor):
    """
    Transforms Kotlin code into Swift code:
    this class  extends the ParseTreeVisitor class 
    to traverse the parse tree generated by the Kotlin parser,
    contains methods that handle various types of statements and expressions, 
    converting them into their corresponding Swift representations.
    """

    def visitProgram(self, ctx):
        print(f"Visiting program: {ctx.getText()}")
        # Ensure to return a string even if ctx.statement() is empty
        statements = [self.visitStatement(stmt) for stmt in ctx.statement()]
        return "\n".join(filter(None, statements))  # Filter out None values

    def visitStatement(self, ctx):
        print(f"Visiting statement: {ctx.getText()}")
        if ctx.ifStatement():
            return self.visitIfStatement(ctx.ifStatement())
        elif ctx.forStatement():
            return self.visitForStatement(ctx.forStatement())
        elif ctx.printStatement():
            return self.visitPrintStatement(ctx.printStatement())
        elif ctx.readStatement():
            return self.visitReadStatement(ctx.readStatement())
        elif ctx.classDeclaration():
            return self.visitClassDeclaration(ctx.classDeclaration())
        return ""  # Return an empty string if no branch is activated

    def visitIfStatement(self, ctx):
        print(f"Visiting if statement: {ctx.getText()}")
        condition = self.visitExpression(ctx.expression())
        body = self.visitBlock(ctx.block())
        return f"if ({condition}):\n{body}"

    def visitForStatement(self, ctx):
        print(f"Visiting for statement: {ctx.getText()}")
        identifier = ctx.IDENTIFIER().getText()
        start = self.visitExpression(ctx.expression(0))  # start expression
        end = self.visitExpression(ctx.expression(1))    # end expression
        body = self.visitBlock(ctx.block())
        return f"for {identifier} in range({start}, {end + 1}):\n{body}"

    def visitPrintStatement(self, ctx):
        print(f"Visiting print statement: {ctx.getText()}")
        expression = self.visitExpression(ctx.expression())
        return f"print({expression})"

    def visitReadStatement(self, ctx):
        print(f"Visiting read statement: {ctx.getText()}")
        identifier = ctx.IDENTIFIER().getText()
        return f"{identifier} = input()"

    def visitClassDeclaration(self, ctx):
        print(f"Visiting declaration: {ctx.getText()}")
        class_name = ctx.IDENTIFIER().getText()
        body = self.visit(ctx.classBody())
        return f"class {class_name}:\n{body}"

    def visitBlock(self, ctx):
        print(f"Visiting block: {ctx.getText()}")
        statements = [self.visitStatement(stmt) for stmt in ctx.statement()]
        return "\n".join(filter(None, statements))  # Filter out None values

    def visitExpression(self, ctx):
        print(f"Visiting expression: {ctx.getText()}")
        if ctx.literal():
            return self.visitLiteral(ctx.literal())
        elif ctx.IDENTIFIER():
            return ctx.IDENTIFIER().getText()
        elif len(ctx.children) == 3:  # Binary operation
            left = self.visitExpression(ctx.expression(0))
            op = ctx.children[1].getText()  # Operator
            right = self.visitExpression(ctx.expression(1))
            return f"{left} {op} {right}"
        return ""  # Return an empty string if it doesn't match any case

    def visitLiteral(self, ctx):
        print(f"Visiting literal: {ctx.getText()}")
        return ctx.getText()  # Return the literal value as text
