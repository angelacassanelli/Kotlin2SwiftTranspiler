from antlr4 import *
from generated.antlr.KotlinParser import KotlinParser

reserved_keywords = {
    "readLine", "println", "val", "var", "Boolean", "Int", "String", 
    "if", "else", "for", "class", "fun", "return", "true", "false", 
    "+", "-", "*", "/", "%", "=", "==", "!=", ">", ">=", "<", "<=",
    ",", ";", ":", ".", "(", ")", "{", "}", "[", "]", "&&", "||",
      "!", "..", "\"", "\'"
}

class KotlinToSwiftVisitor(ParseTreeVisitor):
    """Transforms Kotlin code into Swift code: this class extends the ParseTreeVisitor class 
    to traverse the parse tree generated by the Kotlin parser, containing methods to handle various types 
    of statements and expressions, converting them into their corresponding Swift representations."""

    def __init__(self):
        self.reserved_keywords = reserved_keywords

    kotlin2swiftTypes = {
        "String": "String",
        "Int": "Int",
        "Boolean": "Bool"
    }

    def visitProgram(self, ctx):
        """
        Visits the program node, iterating over statements 
        and joining them into a single Swift program.
        """
        print(f"Visiting program: {ctx.getText()}")
        statements = [self.visitTopLevelStatement(stmt) for stmt in ctx.topLevelStatement()]
        return "\n".join(filter(None, statements))
    
    def visitTopLevelStatement(self, ctx):
        """Determines the type of statement and directs to the appropriate visit method."""
        print(f"Visiting statement: {ctx.getText()}")
        if ctx.classDeclaration():
            return self.visitClassDeclaration(ctx.classDeclaration())
        elif ctx.commentStatement():
            return self.visitCommentStatement(ctx.commentStatement())     
        else: 
            print(f"Unrecognized statement: {ctx.getText()}")
            return ""

    def visitStatement(self, ctx):
        """Determines the type of statement and directs to the appropriate visit method."""
        print(f"Visiting statement: {ctx.getText()}")
        if ctx.readStatement():
            return self.visitReadStatement(ctx.readStatement())
        elif ctx.printStatement():
            return self.visitPrintStatement(ctx.printStatement())
        elif ctx.ifStatement():
            return self.visitIfStatement(ctx.ifStatement())
        elif ctx.forStatement():
            return self.visitForStatement(ctx.forStatement())
        elif ctx.assignmentStatement():
            return self.visitAssignmentStatement(ctx.assignmentStatement())
        elif ctx.varDeclaration(): 
            return self.visitVarDeclaration(ctx.varDeclaration())
        elif ctx.valDeclaration(): 
            return self.visitValDeclaration(ctx.valDeclaration())
        elif ctx.returnStatement():
            return self.visitReturnStatement(ctx.returnStatement())
        elif ctx.commentStatement():
            return self.visitComment(ctx.commentStatement())        
        else: 
            print(f"Unrecognized statement: {ctx.getText()}")
            return ""

    def visitBlock(self, ctx):
        """Visits a block of statements, joining them with newlines."""
        print(f"Visiting block: {ctx.getText()}")        
        for stmt in ctx.statement():
            print(stmt.getText()) 
        statements = [self.visitStatement(stmt) for stmt in ctx.statement()]
        return "\n".join(filter(None, statements))
        
    def visitReadStatement(self, ctx):
        """Converts a Kotlin readLine statement to Swift, supporting optional var/val keyword."""
        print(f"Visiting read statement: {ctx.getText()}")
        identifier = self.visitIdentifier(ctx.IDENTIFIER())
        return f"{identifier} = readLine()"
    
    def visitPrintStatement(self, ctx):
        """Transforms a Kotlin print statement to a Swift print statement."""
        print(f"Visiting print statement: {ctx.getText()}")
        expression = self.visitExpression(ctx.expression())
        return f"print({expression})"
    
    def visitIfStatement(self, ctx):
        """Converts a Kotlin if-else-if statement to Swift, with else and else-if being optional."""
        print(f"Visiting if statement: {ctx.getText()}")
        condition = self.visitExpression(ctx.expression())
        if ctx.block(0): 
            body = self.visitBlock(ctx.block(0))
        else:  
            body = self.visitStatement(ctx.statement(0))
        if ctx.ELSE():
            if ctx.block(1): 
                else_body = self.visitBlock(ctx.block(1))
            else:
                else_body = self.visitStatement(ctx.statement(1))
            return f"if {condition} {{ {body} }} else {{ {else_body} }}"

        return f"if {condition} {{ {body} }}"

    def visitForStatement(self, ctx):
        """Converts a Kotlin for loop with a range to a Swift-compatible loop."""
        print(f"Visiting for statement: {ctx.getText()}")
        expression = self.visitMemebershipExpression(ctx.membershipExpression())
        if ctx.block(): 
            body = self.visitBlock(ctx.block())
        else:  
            body = self.visitStatement(ctx.statement())
        return f"for {expression} {{ {body} }}"


    def visitAssignmentStatement(self, ctx):
        """Converts Kotlin variable assignment to Swift"""
        var_name = self.visitIdentifier(ctx.IDENTIFIER())
        var_value = self.visitExpression(ctx.expression())
        return f"{var_name} = {var_value}"

    def visitVarDeclaration(self, ctx):
        """Converts a Kotlin 'var' declaration to Swift, handling type and optional initialization."""
        print(f"Visiting var declaration: {ctx.getText()}")
        var_name = self.visitIdentifier(ctx.IDENTIFIER())
        var_type = self.visitType(ctx.type_()) if ctx.type_() else None
        if ctx.expression():
            var_value = self.visitExpression(ctx.expression())
        else:
            var_value = None

        declaration = f"var {var_name}"
        if var_type:
            declaration += f": {var_type}"
        if var_value:
            declaration += f" = {var_value}"
        return declaration        

    def visitValDeclaration(self, ctx):
        """Converts a Kotlin 'val' declaration to Swift, handling type and optional initialization."""
        print(f"Visiting val declaration: {ctx.getText()}")
        val_name = self.visitIdentifier(ctx.IDENTIFIER())
        val_type = self.visitType(ctx.type_()) if ctx.type_() else None
        if ctx.expression():
            val_value = self.visitExpression(ctx.expression())
        else:
            val_value = None  
        
        declaration = f"let {val_name}"
        if val_type:
            declaration += f": {val_type}"
        if val_value:
            declaration += f" = {val_value}"
        return declaration
    
    def visitFunctionDeclaration(self, ctx):
        """Visits and transforms a Kotlin function declaration into a Swift function declaration."""
        print(f"Visiting function declaration: {ctx.getText()}")
        func_name = self.visitIdentifier(ctx.IDENTIFIER())
        parameters = self.visitParameterList(ctx.parameterList()) if ctx.parameterList() else ""
        body = self.visitBlock(ctx.block())
        if ctx.type_():
            return_type = self.visitType(ctx.type_()) 
            return f"func {func_name}({parameters}) -> {return_type} {{ {body} }}"
        return f"func {func_name}({parameters}) {{ {body} }}"

    def visitReturnStatement(self, ctx):
        """Visits a 'return' statement."""
        print(f"Visiting return statement: {ctx.getText()}")            
        if ctx.expression():
            expression = self.visitExpression(ctx.expression())
            return f"return {expression}"
        return "return"

    def visitClassDeclaration(self, ctx):
        """Transforms a Kotlin class declaration to Swift, handling class name and body."""
        print(f"Visiting declaration: {ctx.getText()}")
        class_name = self.visitIdentifier(ctx.IDENTIFIER())
        body = self.visitClassBody(ctx.classBody())
        has_parentheses = ctx.LEFT_ROUND_BRACKET() is not None and ctx.RIGHT_ROUND_BRACKET() is not None                    
        if ctx.parameterList():
            constructor_params = self.visitParameterList(ctx.parameterList())
            attributes_declarations = "\n".join([
                f"var {param.split(':')[0].strip()}: {param.split(':')[1].strip().split('=')[0]}"
                for param in constructor_params.split(", ")
            ])
            attributes_assignments = "\n".join([
                f"self.{param.split(':')[0].strip()} = {param.split(':')[0].strip()}"
                for param in constructor_params.split(", ")
            ])
            constructor = f"init({constructor_params}) {{\n{attributes_assignments}\n}}"
            class_declaration = f"class {class_name}()" if has_parentheses else f"class {class_name}"
            return f"{class_declaration} {{\n{attributes_declarations}\n{constructor}\n{body}\n}}"
        class_declaration = f"class {class_name}()" if has_parentheses else f"class {class_name}"
        return f"{class_declaration} {{\n{body}\n}}"
    
    def visitClassBody(self, ctx):
        """Visits the body of a class and processes each statement."""
        print(f"Visiting class body: {ctx.getText()}")
        statements = []
        if ctx.children:
            for stmt in ctx.children:
                if isinstance(stmt, KotlinParser.VarDeclarationContext):
                    statements.append(self.visitVarDeclaration(stmt))
                elif isinstance(stmt, KotlinParser.ValDeclarationContext):
                    statements.append(self.visitValDeclaration(stmt))
                elif isinstance(stmt, KotlinParser.AssignmentStatementContext):
                    statements.append(self.visitAssignmentStatement(stmt))
                elif isinstance(stmt, KotlinParser.FunctionDeclarationContext):
                    statements.append(self.visitFunctionDeclaration(stmt))
                elif isinstance(stmt, KotlinParser.CommentStatementContext):
                    statements.append(self.visitCommentStatement(stmt))
        return "\n".join(filter(None, statements))

    def visitParameterList(self, ctx):
        """Visits and converts a list of Kotlin parameters into a list of Swift parameters."""
        return ", ".join([self.visitParameter(param) for param in ctx.parameter()])
    
    def visitParameter(self, ctx):
        """Visits a parameter and converts it to Swift."""
        param_name = self.visitIdentifier(ctx.IDENTIFIER())
        param_type = self.visitType(ctx.type_()) 
        if (ctx.expression()):
            param_value = self.visitExpression(ctx.expression()) 
            return f"{param_name}: {param_type} = {param_value}"
        return f"{param_name}: {param_type}"

    def visitArgumentList(self, ctx):
        """Visits and converts a list of Kotlin arguments into a list of Swift arguments."""
        return ", ".join([self.visitArgument(argument) for argument in ctx.argument()])
    
    def visitArgument(self, ctx):
        """Visits an argument and converts it to Swift."""
        argument_value = self.visitExpression(ctx.expression()) 
        if (ctx.IDENTIFIER()):
            argument_name = self.visitIdentifier(ctx.IDENTIFIER())
            return f"{argument_name}: {argument_value}"
        return f"{argument_value}"

    def visitExpression(self, ctx: KotlinParser.ExpressionContext):
        print(f"Visiting expression: {ctx.getText()}")
        return self.visitLogicalOrExpression(ctx.logicalOrExpression())  

    def visitLogicalOrExpression(self, ctx: KotlinParser.LogicalOrExpressionContext):
        print(f"Visiting OR expression: {ctx.getText()}")
        left = self.visitLogicalAndExpression(ctx.logicalAndExpression(0))
        for i in range(1, len(ctx.logicalAndExpression())):
            operator = ctx.getChild(2 * i - 1).getText()  # Gli operatori sono al posto 2*i-1 (MULT, DIV, MOD)
            right = self.visitLogicalAndExpression(ctx.logicalAndExpression(i))
            left = f"{left} {operator} {right}" if right is not None else f"{left}"
        return f"{left}"
    
    def visitLogicalAndExpression(self, ctx: KotlinParser.LogicalAndExpressionContext):
        print(f"Visiting AND expression: {ctx.getText()}")
        left = self.visitEqualityExpression(ctx.equalityExpression(0))  
        for i in range(1, len(ctx.equalityExpression())):
            operator = ctx.getChild(2 * i - 1).getText()  # Gli operatori sono al posto 2*i-1 (MULT, DIV, MOD)
            right = self.visitEqualityExpression(ctx.equalityExpression(i)) 
            left = f"{left} {operator} {right}"
        return f"{left}"

    def visitEqualityExpression(self, ctx: KotlinParser.EqualityExpressionContext):
        print(f"Visiting equality expression: {ctx.getText()}")
        left = self.visitRelationalExpression(ctx.relationalExpression(0))
        for i in range(1, len(ctx.relationalExpression())):
            operator = ctx.getChild(2 * i - 1).getText()  # Gli operatori sono al posto 2*i-1 (MULT, DIV, MOD)
            right = self.visitRelationalExpression(ctx.relationalExpression(i))  # Visita il prossimo unary expression
            left = f"{left} {operator} {right}"  # Combina il risultato precedente con l'operatore corrente
        return f"{left}"

    def visitRelationalExpression(self, ctx: KotlinParser.RelationalExpressionContext):
        print(f"Visiting relational expression: {ctx.getText()}")
        left = self.visitAdditiveExpression(ctx.additiveExpression(0))
        if len(ctx.additiveExpression()) > 1:
            operator = ctx.getChild(1).getText()  # Gli operatori sono al posto 2*i-1 (MULT, DIV, MOD)
            right = self.visitAdditiveExpression(ctx.additiveExpression(1))
            return f"{left} {operator} {right}" 
        return f"{left}"

    def visitAdditiveExpression(self, ctx: KotlinParser.AdditiveExpressionContext):
        print(f"Visiting additive expression: {ctx.getText()}")
        left = self.visitMultiplicativeExpression(ctx.multiplicativeExpression(0))
        for i in range(1, len(ctx.multiplicativeExpression())):
            operator = ctx.getChild(2 * i - 1).getText()  # Gli operatori sono al posto 2*i-1 (MULT, DIV, MOD)
            right = self.visitMultiplicativeExpression(ctx.multiplicativeExpression(i))  # Visita il prossimo unary expression
            left = f"{left} {operator} {right}"  # Combina il risultato precedente con l'operatore corrente
        return f"{left}"  

    def visitMultiplicativeExpression(self, ctx: KotlinParser.MultiplicativeExpressionContext):
        """Handles multiplicative expressions like a * b / c % d."""
        print(f"Visiting multiplicative expression: {ctx.getText()}")
        left = self.visitUnaryExpression(ctx.unaryExpression(0))
        for i in range(1, len(ctx.unaryExpression())):
            operator = ctx.getChild(2 * i - 1).getText()  # Gli operatori sono al posto 2*i-1 (MULT, DIV, MOD)
            right = self.visitUnaryExpression(ctx.unaryExpression(i))  # Visita il prossimo unary expression
            left = f"{left} {operator} {right}"  # Combina il risultato precedente con l'operatore corrente
        return f"{left}" 

    def visitUnaryExpression(self, ctx: KotlinParser.UnaryExpressionContext):
        print(f"Visiting unary expression: {ctx.getText()}")
        if ctx.NOT(): 
            return f"!{self.visitPrimaryExpression(ctx.primaryExpression())}"
        elif ctx.MINUS():
            return f"-{self.visitPrimaryExpression(ctx.primaryExpression())}"
        else:
            return f"{self.visitMemebershipExpression(ctx.membershipExpression())}"

    def visitMemebershipExpression(self, ctx: KotlinParser.PrimaryExpressionContext):
        print(f"Visiting membership expression: {ctx.getText()}")
        left = self.visitPrimaryExpression(ctx.primaryExpression())
        if ctx.rangeExpression():
            right = self.visitRangeExpression(ctx.rangeExpression()) 
            if ctx.NOT() and ctx.IN():
                return f"{left} !in {right}"
            elif ctx.IN():
                return f"{left} in {right}"
        return f"{left}"
    
    def visitPrimaryExpression(self, ctx: KotlinParser.PrimaryExpressionContext):
        print(f"Visiting primary expression: {ctx.getText()}")
        if ctx.IDENTIFIER():
            return ctx.IDENTIFIER().getText()  
        elif ctx.LEFT_ROUND_BRACKET() and ctx.RIGHT_ROUND_BRACKET():
            return f"({self.visitExpression(ctx.expression())})"  
        elif ctx.callExpression():
            return self.visitCallExpression(ctx.callExpression())
        elif ctx.literal():
            return self.visitLiteral(ctx.literal())

    def visitRangeExpression(self, ctx: KotlinParser.PrimaryExpressionContext):
        print(f"Visiting range expression: {ctx.getText()}")
        left = self.visitAdditiveExpression(ctx.additiveExpression(0))
        right = self.visitAdditiveExpression(ctx.additiveExpression(1))        
        return f"{left} ... {right}"

    def visitCallExpression(self, ctx):
        print(f"Visiting function statement: {ctx.getText()}")
        func_name = self.visitIdentifier(ctx.IDENTIFIER())
        arguments = self.visitArgumentList(ctx.argumentList()) if ctx.argumentList() else ""
        return f"{func_name}({arguments})"

    def visitLiteral(self, ctx):
        """Returns the literal value as text for Swift conversion."""
        print(f"Visiting literal: {ctx.getText()}")
        return ctx.getText()

    def visitCommentStatement(self, ctx):
        """Trannsforms inline and blockc comments."""
        print(f"Visiting comment: {ctx.getText()}")
        if ctx.LINE_COMMENT():
            return self.visitLineComment(ctx.LINE_COMMENT())
        elif ctx.BLOCK_COMMENT():
            return self.visitBlockComment(ctx.BLOCK_COMMENT())
        else:
            return ""
    
    def visitLineComment(self, ctx):
        """Transforms inline comments."""
        print(f"Visiting inline comment: {ctx.getText()}")
        comment = ctx.getText()[2:].strip() 
        return f"# {comment}"

    def visitBlockComment(self, ctx):
        """Transforms block comments."""
        print(f"Visiting block: {ctx.getText()}")
        comment = ctx.getText()[2:-2].strip() 
        return f"/* {comment} */"    

    def visitType(self, ctx): 
        """Maps a Kotlin type to its Swift equivalent, defaulting to the original type if unmapped."""
        kotlin_type = ctx.getText()  
        swift_type = self.kotlin2swiftTypes.get(kotlin_type, kotlin_type)  
        return swift_type

    def visitIdentifier(self, ctx):
        """Checks if the identifier is a reserved keyword and raises an error if so."""
        print(f"Visiting identifier: {ctx.getText()}")
        identifier_name = ctx.getText()
        if identifier_name in self.reserved_keywords:
            raise ValueError(f"Error: '{identifier_name}' is a reserved keyword and cannot be used as an identifier.")
        return identifier_name
