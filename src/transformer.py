from antlr4 import *

class KotlinToSwiftTransformer(ParseTreeVisitor):
    """
    Transforms Kotlin code into Swift code:
    this class  extends the ParseTreeVisitor class 
    to traverse the parse tree generated by the Kotlin parser,
    contains methods that handle various types of statements and expressions, 
    converting them into their corresponding Swift representations.
    """

    kotlin2swiftTypes = {
        "String": "String",
        "Int": "Int",
        "Boolean": "Bool"
    }

    def visitProgram(self, ctx):
        print(f"Visiting program: {ctx.getText()}")
        # Ensure to return a string even if ctx.statement() is empty
        statements = [self.visitStatement(stmt) for stmt in ctx.statement()]
        return "\n".join(filter(None, statements))  # Filter out None values

    def visitStatement(self, ctx):
        print(f"Visiting statement: {ctx.getText()}")
        if ctx.varDeclaration(): 
            return self.visitVarDeclaration(ctx.varDeclaration())
        elif ctx.valDeclaration(): 
            return self.visitValDeclaration(ctx.valDeclaration())
        elif ctx.ifStatement():
            return self.visitIfStatement(ctx.ifStatement())
        elif ctx.forStatement():
            return self.visitForStatement(ctx.forStatement())
        elif ctx.printStatement():
            return self.visitPrintStatement(ctx.printStatement())
        elif ctx.readStatement():
            return self.visitReadStatement(ctx.readStatement())
        elif ctx.classDeclaration():
            return self.visitClassDeclaration(ctx.classDeclaration())
        else: 
            print(f"Unrecognized statement: {ctx.getText()}")
            return ""  # Return an empty string if no branch is activated
        
    def visitVarDeclaration(self, ctx):
        print(f"Visiting var declaration: {ctx.getText()}")
        var_name = ctx.IDENTIFIER().getText()
        var_type = self.visitType(ctx.type_()) if ctx.type_() else "Any"
        var_value = self.visitExpression(ctx.expression()) if ctx.expression() else "nil"
        return f"var {var_name}: {var_type} = {var_value}"

    def visitValDeclaration(self, ctx):
        print(f"Visiting val declaration: {ctx.getText()}")
        val_name = ctx.IDENTIFIER().getText()
        val_type = self.visitType(ctx.type_()) if ctx.type_() else "Any"
        val_value = self.visitExpression(ctx.expression()) if ctx.expression() else "nil"
        return f"let {val_name}: {val_type} = {val_value}"

    def visitType(self, ctx): 
        kotlin_type = ctx.getText()  
        swift_type = self.kotlin2swiftTypes.get(kotlin_type, kotlin_type)  
        return swift_type

    def visitIfStatement(self, ctx):
        print(f"Visiting if statement: {ctx.getText()}")
        condition = self.visitExpression(ctx.expression())
        body = self.visitBlock(ctx.block()[0])
        return f"if ({condition}):\n{body}"

    def visitForStatement(self, ctx):
        print(f"Visiting for statement: {ctx.getText()}")
        identifier = ctx.IDENTIFIER().getText()
        start = self.visitExpression(ctx.expression(0))  # start expression
        end = self.visitExpression(ctx.expression(1))    # end expression
        body = self.visitBlock(ctx.block())
        return f"for {identifier} in range({start}, {end}):\n{body}"

    def visitPrintStatement(self, ctx):
        print(f"Visiting print statement: {ctx.getText()}")
        expression = self.visitExpression(ctx.expression())
        return f"print({expression})"

    def visitReadStatement(self, ctx):
        print(f"Visiting read statement: {ctx.getText()}")
        identifier = ctx.IDENTIFIER().getText()
        return f"{identifier} = input()"

    def visitClassDeclaration(self, ctx):
        print(f"Visiting declaration: {ctx.getText()}")
        class_name = ctx.IDENTIFIER().getText()
        body = self.visit(ctx.classBody())
        return f"class {class_name}:\n{body}"

    def visitBlock(self, ctx):
        print(f"Visiting block: {ctx.getText()}")        
        for stmt in ctx.statement():
            print(stmt.getText()) 
        statements = [self.visitStatement(stmt) for stmt in ctx.statement()]
        return "\n".join(filter(None, statements)) 

    def visitExpression(self, ctx):
        print(f"Visiting expression: {ctx.getText()}")
        if ctx.literal():
            return self.visitLiteral(ctx.literal())
        elif ctx.IDENTIFIER():
            return ctx.IDENTIFIER().getText()
        elif len(ctx.children) == 3:  # Binary operation
            left = self.visitExpression(ctx.expression(0))
            op = ctx.children[1].getText()  # Operator
            right = self.visitExpression(ctx.expression(1))
            return f"{left} {op} {right}"
        else:
            print(f"Unrecognized expression format: {ctx.getText()}")
            return ""  # Fallback for unrecognized expression

    def visitLiteral(self, ctx):
        print(f"Visiting literal: {ctx.getText()}")
        return ctx.getText()  # Return the literal value as text
