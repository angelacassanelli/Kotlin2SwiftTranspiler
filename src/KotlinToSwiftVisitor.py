from antlr4 import ParseTreeVisitor
from generated.antlr.KotlinParser import KotlinParser
from Symbol import Symbol
from Types import KotlinTypes
from Utils import KOTLIN_2_SWIFT_TYPES, RESERVED_KEYWORDS


class KotlinToSwiftVisitor(ParseTreeVisitor):
    
    """
    This class is responsible for translating Kotlin code into Swift. It visits the parse tree
    generated by the ANTLR parser, converting Kotlin constructs into their Swift equivalents. 
    It also handles semantic checks.

    Attributes:
        symbol_table (SymbolTable): The symbol table that stores variables, functions, and classes.
        semantic_error_listener (SemanticErrorListener): A listener for semantic errors.
        kotlin_2_swift_types (dict): A dictionary that maps Kotlin types to corresponding Swift types.
        reserved_keywords (set): A set of reserved keywords in Kotlin that cannot be used as identifiers.
    """


    def __init__(self, symbol_table, semantic_error_listener):
        """
        Initializes an instance of the Kotlin-to-Swift visitor.

        This constructor sets the symbol table and semantic error listener for error checking
        during translation. It also sets up dictionaries for type mapping and reserved keyword management.

        Args:
            symbol_table (SymbolTable): The symbol table.
            semantic_error_listener (SemanticErrorListener): An object that handles semantic errors.

        Attributes:
            symbol_table (SymbolTable): The symbol table that stores variables, functions, and classes.
            semantic_error_listener (SemanticErrorListener): A listener for semantic errors.
            kotlin_2_swift_types (dict): A dictionary that maps Kotlin types to corresponding Swift types.
            reserved_keywords (set): A set of reserved keywords in Kotlin that cannot be used as identifiers.            
        """
        self.symbol_table = symbol_table
        self.semantic_error_listener = semantic_error_listener        
        self.kotlin_2_swift_types = KOTLIN_2_SWIFT_TYPES
        self.reserved_keywords = RESERVED_KEYWORDS


    def visit_program(self, ctx: KotlinParser.ProgramContext):        
        """
        Visits the program node in the Kotlin Parse Tree and translates
        top-level statements into corresponding Swift code.

        This method iterates over the top-level statements of the Kotlin program, converts
        each statement into Swift code, and joins the results into a single Swift program.

        Args:
            ctx (KotlinParser.ProgramContext): The context object representing the program node 
                                               in the Kotlin Parse Tree.

        Returns:
            str: The translated Swift code, with top-level statements joined into a single string.

        Raises:
            ValueError: If the program contains invalid top-level statements.
        """     
        print("üöÄ Visiting Kotlin code...")
        print(f"    üîç Visiting program: {ctx.getText()}")
        
        if(ctx.topLevelStatement()):
            statements = [self.visit_top_level_statement(stmt) for stmt in ctx.topLevelStatement()]
            return "\n".join(filter(None, statements)) # Joins non-empty strings with a newline separator.
        else:
            raise ValueError(f"    ‚ùå Invalid top level statement in program.")


    def visit_top_level_statement(self, ctx: KotlinParser.TopLevelStatementContext):
        """
        Handles different types of top-level statements in the Kotlin program and directs them 
        to the appropriate visit methods for further processing.

        This method checks the type of the top-level statement (e.g., class declaration or comment),
        and delegates to the corresponding method for further handling. If the statement type is 
        unrecognized, it prints an error message.

        Args:
            ctx (KotlinParser.TopLevelStatementContext): The context object representing the top-level 
                                                         statement in the Kotlin Parse Tree.

        Returns:
            str or None: The translated Swift code for the top-level statement, or None if the statement 
                         is unrecognized.

        Prints:
            An error message if the statement is unrecognized.
        """
        print(f"    üîç Visiting top level statement: {ctx.getText()}")
        
        if ctx.classDeclaration():
            return self.visit_class_declaration(ctx.classDeclaration())
        elif ctx.commentStatement():
            return self.visit_comment_statement(ctx.commentStatement())     
        else: 
            print(f"    ‚ùå Unrecognized statement: {ctx.getText()}")
            return None


    def visit_class_declaration(self, ctx: KotlinParser.ClassDeclarationContext):
        """
        Converts a Kotlin class declaration into a Swift class declaration.

        This method processes a Kotlin class declaration and translates it into Swift syntax, 
        including the class name, properties, constructor, and class body. It also checks for 
        duplicate class declarations in the current scope and ensures that the class is added 
        to the symbol table for semantic analysis.

        The method handles:
        - Class properties (with optional values).
        - Constructor parameters and their default values.
        - Class body content (if available).
        
        If the class has properties, it generates property declarations, assignments, and 
        constructs an initializer method in Swift. If no properties are present, it generates 
        only the initializer method if parameters are specified, otherwise the class will be 
        declared without a constructor body.

        Args:
            ctx (KotlinParser.ClassDeclarationContext): The context object representing the class declaration
                                                        in the Kotlin Parse Tree.

        Returns:
            str: The translated Swift code for the class declaration.

        Raises:
            ValueError: If properties in the class declaration are incorrectly formatted.

        Prints:
            An error message if the class has already been declared in the current scope.
        """
        print(f"    üîç Visiting class declaration: {ctx.getText()}")

        class_name = self.visit_identifier(ctx.IDENTIFIER())

        if self.check_class_already_declared_in_current_scope(ctx = ctx, class_name=class_name):
            return None
        else:
            self.symbol_table.add_class(class_name)
            self.symbol_table.add_scope()

            propertyList = self.visit_property_list(ctx.propertyList()) if ctx.propertyList() else None
            constructor_params = self.visit_parameter_list(ctx.parameterList()) if ctx.parameterList() else None
            body = self.visit_class_body(ctx.classBody()) if ctx.classBody() else ""            
            
            has_parentheses = ctx.LEFT_ROUND_BRACKET() is not None and ctx.RIGHT_ROUND_BRACKET() is not None                    
            
            if propertyList: 
                properties_declarations = []
                properties_assignments = []
                constructor_params = []

                for property in propertyList:
                    values = property.split()

                    if len(values) == 4:
                        var_keyword, var_name, _, var_type = values
                        var_value = None
                    elif len(values) == 6:
                        var_keyword, var_name, _, var_type, _, var_value = values                    
                    else:
                        raise ValueError(f"    ‚ùå Invalid properties: {propertyList}")
    
                    properties_declarations.append(f"{var_keyword} {var_name}: {var_type}")
                    properties_assignments.append(f"self.{var_name} = {var_name}")
                    constructor_params.append(f"{var_name}: {var_type}" + (f" = {var_value}" if var_value is not None else ""))
    
                properties_declarations = "\n".join(properties_declarations)
                properties_assignments = "\n".join(properties_assignments)
                constructor_params = ", ".join(constructor_params)

                constructor = f"init({constructor_params}) {{\n{properties_assignments}\n}}"
                class_declaration = f"class {class_name}()" if has_parentheses else f"class {class_name}"
                return f"{class_declaration} {{\n{properties_declarations}\n{constructor}\n{body}\n}}"
            
            elif constructor_params:
                constructor = f"init({constructor_params}) {{}}"
                class_declaration = f"class {class_name}()" if has_parentheses else f"class {class_name}"
                return f"{class_declaration} {{\n{constructor}\n{body}\n}}"
            
            self.symbol_table.remove_scope()

            class_declaration = f"class {class_name}()" if has_parentheses else f"class {class_name}"
            return f"{class_declaration} {{\n{body}\n}}"
    

    def visit_identifier(self, ctx: KotlinParser):
        """
        Handles identifiers in the Kotlin code, ensuring they are not reserved keywords.

        This method checks whether an identifier is a reserved keyword in Kotlin and raises an 
        error if the identifier conflicts with any keyword. It processes the identifier by 
        extracting its name from the given context and ensures that it can be safely used in 
        the translated Swift code.

        Args:
            ctx (KotlinParser): The context object representing the identifier in the Kotlin 
                                Parse Tree.

        Returns:
            str: The name of the identifier, if it is not a reserved keyword.

        Raises:
            ValueError: If the identifier is a reserved keyword in Kotlin.
        """
        print(f"    üîç Visiting identifier: {ctx.getText()}")
        
        identifier_name = ctx.getText()
        if identifier_name in self.reserved_keywords:
            raise ValueError(f"    ‚ùå '{identifier_name}' is a reserved keyword and cannot be used as an identifier.")
        return identifier_name
    

    def visit_property_list(self, ctx: KotlinParser.PropertyListContext):
        """
        Converts a list of Kotlin properties into Swift properties.

        This method iterates over a list of properties in a Kotlin class and translates each
        property into its corresponding Swift declaration using the `visit_property` method.
        It processes the entire property list and returns the converted list of properties 
        in Swift syntax.

        Args:
            ctx (KotlinParser.PropertyListContext): The context object representing the list of properties 
                                                    in the Kotlin Parse Tree.

        Returns:
            list: A list of strings representing the properties in Swift syntax.
        """
        print(f"    üîç Visiting property list: {ctx.getText()}")
        
        return [self.visit_property(property) for property in ctx.property_()]


    def visit_property(self, ctx: KotlinParser.PropertyContext):
        """
        Converts a Kotlin property into a Swift property.

        This method processes a Kotlin property and translates it into the corresponding Swift 
        property declaration. It does so by delegating to the `visit_var_declaration` method 
        for further processing of the variable declaration associated with the property.

        Args:
            ctx (KotlinParser.PropertyContext): The context object representing the property 
                                                in the Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift property declaration.
        """
        print(f"    üîç Visiting property: {ctx.getText()}")
        
        return self.visit_var_declaration(ctx.varDeclaration())
    

    def visit_parameter_list(self, ctx: KotlinParser.ParameterListContext):
        """
        Converts a list of Kotlin parameters into Swift parameters.

        This method processes a list of Kotlin parameters and converts them into a comma-separated 
        list of Swift parameters by delegating to the `visit_parameter` method for each parameter 
        in the list.

        Args:
            ctx (KotlinParser.ParameterListContext): The context object representing the parameter list 
                                                     in the Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift parameter list, with each parameter separated by a comma.
        """
        print(f"    üîç Visiting parameter list: {ctx.getText()}")
        
        return ", ".join([self.visit_parameter(param) for param in ctx.parameter()])


    def visit_parameter(self, ctx: KotlinParser.ParameterContext):
        """
        Converts a Kotlin parameter into a Swift parameter.

        This method processes a Kotlin parameter, extracting its name and type, and optionally 
        its value if provided. It then converts the parameter into a Swift-compatible format, 
        with default values handled appropriately.

        Args:
            ctx (KotlinParser.ParameterContext): The context object representing the parameter 
                                                 in the Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift parameter, with its name, type, and optional 
            default value (if available).
        """
        print(f"    üîç Visiting parameter: {ctx.getText()}")
        
        param_name = self.visit_identifier(ctx.IDENTIFIER())
        param_type = self.visit_type(ctx.type_()) 
        if (ctx.expression()):
            param_value = self.visit_expression(ctx.expression()) 
            return f"{param_name}: {param_type} = {param_value}"
        return f"{param_name}: {param_type}"


    def visit_class_body(self, ctx: KotlinParser.ClassBodyContext):
        """
        Handles the body of a Kotlin class, converting its statements into Swift code.

        This method processes the body of a Kotlin class, iterating over its statements (such as 
        variable declarations, function declarations, assignment statements, and comments), 
        converting them into their Swift equivalents. Unrecognized statements are logged as errors.

        Args:
            ctx (KotlinParser.ClassBodyContext): The context object representing the body of the Kotlin 
                                                 class in the Kotlin Parse Tree.

        Returns:
            str: A string containing the converted Swift code for the class body, with each 
            statement separated by newlines.

        Raises:
            ValueError: If an invalid statement is encountered in the class body.
        """
        print(f"    üîç Visiting class body: {ctx.getText()}")
        statements = []
        if ctx.children:
            for stmt in ctx.children:
                if isinstance(stmt, KotlinParser.VarDeclarationContext):                
                    statements.append(self.visit_var_declaration(stmt))
                elif isinstance(stmt, KotlinParser.FunctionDeclarationContext):
                    statements.append(self.visit_function_declaration(stmt))
                elif isinstance(stmt, KotlinParser.AssignmentStatementContext):
                    statements.append(self.visit_assignment_statement(stmt))
                elif isinstance(stmt, KotlinParser.CommentStatementContext):
                    statements.append(self.visit_comment_statement(stmt))
                else:
                    print(f"    ‚ùå Unrecognized statement: {stmt.getText()}")
                    return ""
            # Join and return the non-empty statements
            return "\n".join(filter(None, statements))
        else:
            raise ValueError(f"    ‚ùå Invalid statement in class body.")


    def visit_var_declaration(self, ctx: KotlinParser.VarDeclarationContext):
        """
        Converts a Kotlin 'var' declaration to Swift, including type and optional initialization.

        This method processes a Kotlin variable declaration, converting it into the equivalent 
        Swift declaration. It handles both mutable and immutable variables, checks for type 
        mismatches and unsupported types, and validates initialization expressions. 
        It also adds the variable to the symbol table if the declaration is valid. The resulting 
        Swift declaration is returned as a string, or None is returned if errors are encountered.

        Args:
            ctx (KotlinParser.VarDeclarationContext): The context object representing the variable 
                                                      declaration in the Kotlin Parse Tree.

        Returns:
            str: A string containing the converted Swift variable declaration, including the 
            type and value (if available). Returns None if the declaration is invalid.

        Raises:
            None: This method may invoke the semantic error listener in case of type mismatches
            or unsupported types detected.
        """
        print(f"    üîç Visiting variable declaration: {ctx.getText()}")
        
        var_name = self.visit_identifier(ctx.IDENTIFIER())        
        mutable, keyword = (False, "let") if ctx.VAL() else (True, "var")

        # Check if the variable is already declared
        if self.check_variable_already_declared_in_current_scope(ctx = ctx, var_name = var_name):
            return None
        else:
            # Check unsupported type            
            kotlin_type = ctx.type_().getText() if ctx.type_() else self.check_expression_type(ctx.expression())

            if not self.check_supported_type(ctx = ctx, type=kotlin_type):
                return None

            # Check type mismatch, if variable is assigned            
            if ctx.expression():
                # Check type mismatch
                if not self.validate_value(ctx=ctx, type=kotlin_type):
                    return None
                var_value = self.visit_expression(ctx.expression()) 
            elif ctx.readStatement():
                # Check type is String 
                if kotlin_type != KotlinTypes.STRING.value:
                    self.semantic_error_listener.semantic_error(
                        msg = f"Type mismatch: Variable declared as '{kotlin_type}' but assigned a value of type 'String'.", 
                        line = ctx.start.line, 
                        column = ctx.start.column
                    )
                    return None
                var_value = self.visit_read_statement(ctx.readStatement())
            else:
                var_value = None
            
            # Add the variable to the symbol table
            self.add_variable_to_symbol_table(var_name=var_name, type=kotlin_type, mutable=mutable, value=var_value)
            
            swift_type = self.visit_type(ctx.type_()) if ctx.type_() else None
            
            swift_var_declaration = f"{keyword} {var_name}"
                        
            if swift_type:
                swift_var_declaration += f" : {swift_type}"

            if var_value:
                swift_var_declaration += f" = {var_value}"
            
            return swift_var_declaration     


    def visit_type(self, ctx: KotlinParser.TypeContext): 
        """
        Converts Kotlin types to Swift types.

        This method processes a Kotlin type and converts it into the corresponding Swift type.
        If the Kotlin type is not supported, it returns None.

        Args:
            ctx (KotlinParser.TypeContext): The context object representing the Kotlin type 
                                            in the Kotlin Parse Tree.

        Returns:
            str: The corresponding Swift type as a string, or None if the Kotlin type is unsupported.
        """
        print(f"    üîç Visiting type: {ctx.getText()}")
        
        kotlin_type = ctx.getText()  
        swift_type = self.kotlin_2_swift_types.get(KotlinTypes[kotlin_type.upper()], None)  
        if not swift_type:
            return None
        return swift_type.value   
    

    def visit_assignment_statement(self, ctx: KotlinParser.AssignmentStatementContext):
        """
        Converts Kotlin variable assignment to Swift.

        This method handles the conversion of Kotlin variable assignments to Swift syntax. 
        It checks whether the assignment is a regular variable assignment or a function call, 
        handling both scenarios accordingly. It checks for mutability, variable declarations, 
        and type mismatches. It also updates the variable value in the symbol table. 
        If the assignment involves a read statement, it ensures that the correct type is assigned.

        Args:
            ctx (KotlinParser.AssignmentStatementContext): The context object representing the assignment 
                                                           statement in the Kotlin Parse Tree.

        Returns:
            str: The Swift equivalent of the Kotlin assignment statement or None if there is an error, 
            such as an undeclared variable, a mutability issue, or a type mismatch.
        """
        print(f"    üîç Visiting assignment statement: {ctx.getText()}")
        
        # Workaround for handling both assignments and function calls in the same rule.
        # If the assignment is a function call (e.g., test()), the callExpression is visited.
        # Otherwise, it processes the regular variable assignment.
        if ctx.callExpression():
            return self.visit_call_expression(ctx.callExpression()) 
        else:        
            var_name = self.visit_identifier(ctx.IDENTIFIER())

            # Check if variable is declared
            if not self.check_variable_already_declared(ctx=ctx, var_name=var_name):        
                return None
            else:
                var_type, is_mutable = self.symbol_table.get_variable_info(var_name) 

                # Check mutability
                if not self.check_mutability(ctx=ctx, var_name=var_name, is_mutable=is_mutable):
                    return None
                
                if ctx.readStatement():
                    # Check type is String 
                    if var_type != KotlinTypes.STRING.value:
                        self.semantic_error_listener.semantic_error(
                            msg = f"Type mismatch: Variable declared as '{var_type}' but assigned a value of type 'String'.", 
                            line = ctx.start.line, 
                            column = ctx.start.column
                        )
                        return None
                
                    var_value = self.visit_read_statement(ctx=ctx.readStatement())
                    self.symbol_table.update_variable(name=var_name, new_value=var_value) 
                    return f"{var_name} = {var_value}"
                else:
                    # Check type mismatch            
                    if not self.validate_value(ctx=ctx, type=var_type):
                        return None
                
                    var_value = self.visit_expression(ctx=ctx.expression())
                    self.symbol_table.update_variable(name=var_name, new_value=var_value) 
                    return f"{var_name} = {var_value}"


    def visit_function_declaration(self, ctx: KotlinParser.FunctionDeclarationContext):
        """
        Transforms a Kotlin function declaration into a Swift function declaration.

        This method converts a Kotlin function declaration into the corresponding Swift syntax.
        It handles both functions with and without return types. It handles return type checking
        and consistency: it verifies the presence of a return statement in the function body and 
        checks if the return value matches the expected return type, or it verifies that no 
        return statement is present if the function has no return type. It handles scope management, 
        parameter type checking and ensures there are no duplicate parameters. Additionally, It adds 
        the function and its parameters to the symbol table, and creates the Swift function declaration 
        based on the provided information.

        Args:
            ctx (KotlinParser.FunctionDeclarationContext): The context object representing the 
                                                           function declaration in the Kotlin 
                                                           Parse Tree.

        Returns:
            str: The Swift equivalent of the Kotlin function declaration or None if the function 
                 is already declared or if there are errors such as unsupported types, duplicate 
                 parameters, or missing return types.
        """
        print(f"    üîç Visiting function declaration: {ctx.getText()}")

        fun_name = self.visit_identifier(ctx.IDENTIFIER())   
        kotlin_param_types = self.check_parameter_type_list(ctx.parameterList()) if ctx.parameterList() else None

        # Check if the variable is already declared
        if self.check_function_already_declared_in_current_scope(ctx = ctx, fun_name = fun_name, kotlin_param_types=kotlin_param_types):        
            return None
        else:
            param_names = self.check_parameter_name_list(ctx.parameterList()) if ctx.parameterList() else None
            param_names_values = self.check_parameter_name_value_list(ctx.parameterList()) if ctx.parameterList() else None

            if ctx.type_():
                kotlin_return_type = ctx.type_().getText()
                # Check unsupported return type
                if not self.check_supported_type(ctx = ctx, type=kotlin_return_type):
                    return None
            else:
                kotlin_return_type = None
        
            self.symbol_table.add_function(fun_name, kotlin_param_types, param_names, kotlin_return_type)
            self.symbol_table.add_scope() 

            if ctx.parameterList():
                param_names_values_dict = {
                    item.split(": ")[0]: item.split(": ")[1] if item.split(": ")[1] != "None" else None
                    for item in param_names_values.split(", ")
                }
                
                for param_type, param_name in zip(kotlin_param_types.split(", "), param_names.split(", ")):
                    if self.check_variable_already_declared_in_current_scope(ctx = ctx, var_name = param_name):
                        continue
                    
                    # Get value form param_names_values_dict
                    param_value = param_names_values_dict.get(param_name, None)

                    # Add the variable to the symbol table
                    self.add_variable_to_symbol_table(var_name=param_name, type=param_type, mutable=False, value=param_value) 

                # Check if the function declaration contains duplicated parameters
                if not self.check_duplicate_parameters(ctx = ctx.parameterList(), fun_name=fun_name): 
                    return None

            parameters = self.visit_parameter_list(ctx.parameterList()) if ctx.parameterList() else ""

            body = self.visit_block(ctx.block())        

            # Check if the function body contains a return statement and that the return value matches the return type
            if not self.check_return_statement(ctx = ctx.block(), fun_name = fun_name, fun_return_type = kotlin_return_type):
                return None

            if ctx.type_():
                return_type = self.visit_type(ctx.type_()) 
                swift_function = f"func {fun_name}({parameters}) -> {return_type} {{{body}}}"
            else:
                swift_function = f"func {fun_name}({parameters}) {{{body}}}"

            self.symbol_table.remove_scope()

            return swift_function


    def visit_block(self, ctx: KotlinParser.BlockContext):
        """
        Visits a block of statements and joins them with newlines.

        This method processes a block of Kotlin statements and generates the corresponding Swift code. 
        It visits each statement within the block, invoking the appropriate visit method for each statement, 
        and then joins the results with newlines to form a properly structured Swift code block, filtering 
        out any empty or unrecognized statements.

        Args:
            ctx (KotlinParser.BlockContext): The context object representing the block of statements in the 
                                             Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift equivalent of the Kotlin block, with each statement 
                 joined by a newline.
        """
        print(f"    üîç Visiting block: {ctx.getText()}")        
        
        statements = [self.visit_statement(stmt) for stmt in ctx.statement()]
        return "\n" + "\n".join(filter(None, statements)) + "\n"


    def visit_statement(self, ctx: KotlinParser.StatementContext):
        """
        Handles various types of statements and converts them to Swift.

        This method processes different types of Kotlin statements by delegating the work to specific 
        visit methods based on the type of the statement. The corresponding Swift code for each statement 
        is generated and returned.

        Args:
            ctx (KotlinParser.StatementContext): The context object representing the statement in the 
                                                 Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift equivalent of the Kotlin statement. If the statement is 
                 unrecognized or invalid, an empty string is returned.
        """
        print(f"    üîç Visiting statement: {ctx.getText()}")
        if ctx.readStatement():
            return self.visit_read_statement(ctx.readStatement())
        elif ctx.printStatement():
            return self.visit_print_statement(ctx.printStatement())
        elif ctx.ifElseStatement():
            return self.visit_if_else_statement(ctx.ifElseStatement())
        elif ctx.forStatement():
            return self.visit_for_statement(ctx.forStatement())
        elif ctx.assignmentStatement():
            return self.visit_assignment_statement(ctx.assignmentStatement())
        elif ctx.varDeclaration(): 
            return self.visit_var_declaration(ctx.varDeclaration())
        elif ctx.returnStatement():
            return self.visit_return_statement(ctx.returnStatement())
        elif ctx.commentStatement():
            return self.visit_comment_statement(ctx.commentStatement())        
        else: 
            print(f"    ‚ùå Unrecognized statement: {ctx.getText()}")
            return ""
        

    def visit_read_statement(self, ctx: KotlinParser.ReadStatementContext):
        """
        Converts a Kotlin readLine statement to Swift, handling the conversion to the appropriate 
        Swift syntax.

        This method handles Kotlin's `readLine()` function, converting it to the corresponding Swift syntax 
        for reading input from the user. This function only processes the statement itself.

        Args:
            ctx (KotlinParser.ReadStatementContext): The context object representing the `readLine` statement 
                                                     in the Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift equivalent of the Kotlin `readLine()` statement.
        """        
        print(f"    üîç Visiting read statement: {ctx.getText()}")
        return f"readLine()"
    

    def visit_print_statement(self, ctx: KotlinParser.PrintStatementContext):
        """
        Translates a Kotlin print statement to its Swift equivalent.

        This method transforms Kotlin's `println()` function into Swift's `print()` function.
        The expression inside the print statement is processed using the `visit_expression()` method.

        Args:
            ctx (KotlinParser.PrintStatementContext): The context object representing the Kotlin print 
                                                      statement in the Kotlin Parse Tree.

        Returns:
            str: A string containing the Swift equivalent of the Kotlin print statement.
        """
        print(f"    üîç Visiting print statement: {ctx.getText()}")
        
        expression = self.visit_expression(ctx.expression())
        
        # Check the variable in the expression is declared if it references a variable
        self.check_expression_type(ctx.expression())
        
        return f"print({expression})"
    

    def visit_if_else_statement(self, ctx: KotlinParser.IfElseStatementContext):
        """
        Converts a Kotlin if-else statement into a Swift if-else statement.

        This method processes the Kotlin `if`-`else` construct, converting it to the Swift equivalent. 
        It handles both the `if` block and the optional `else` block, including the condition expression and 
        bodies of the statements. This method calls `visit_expression()` to process the condition expression
        and `validate_if_condition()` to ensure the condition is valid.

        Args:
            ctx (KotlinParser.IfElseStatementContext): The context object representing the Kotlin `if`-`else` 
                                                       statement in the Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift equivalent of the Kotlin `if`-`else` statement.
        """
        print(f"    üîç Visiting if statement: {ctx.getText()}")
        
        condition = self.visit_expression(ctx.expression())
        
        if not self.validate_if_condition(ctx):
            return None

        if_body = self.visit_if_body(ctx.ifBody())

        if ctx.ELSE():
            else_body = self.visit_else_body(ctx.elseBody())

            return f"if {condition} {{{if_body}}} else {{{else_body}}}"

        return f"if {condition} {{{if_body}}}"

    
    def visit_if_body(self, ctx: KotlinParser.IfBodyContext):
        """
        Converts the body of a Kotlin `if` statement to its Swift equivalent.

        This method processes the body of the `if` block in a Kotlin `if-else` statement. If the body is a 
        block of statements, it recursively visits the block; otherwise, it processes the single statement 
        in the body.

        Args:
            ctx (KotlinParser.IfBodyContext): The context object representing the body of the `if` statement 
                                              in the Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift equivalent of the Kotlin `if` body, 
                 either a block of statements or a single statement.
        """
        print(f"    üîç Visiting if-else statement: {ctx.getText()}")
        
        return self.visit_block(ctx.block()) if ctx.block() else self.visit_statement(ctx.statement())


    def visit_else_body(self, ctx: KotlinParser.ElseBodyContext):
        """
        Converts the body of a Kotlin `else` block in an `if-else` statement to its Swift equivalent.

        This method processes the body of the `else` block in a Kotlin `if-else` statement. If the body 
        is a block of statements, it recursively visits the block; otherwise, it processes the single 
        statement in the body.

        Args:
            ctx (KotlinParser.ElseBodyContext): The context object representing the body of the `else` block 
                                                in the Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift equivalent of the Kotlin `else` body, either a block of 
                 statements or a single statement.
        """
        print(f"    üîç Visiting if-else statement: {ctx.getText()}")
        
        return self.visit_block(ctx.block()) if ctx.block() else self.visit_statement(ctx.statement())


    def visit_for_statement(self, ctx: KotlinParser.ForStatementContext):
        """
        Converts a Kotlin `for` loop into a Swift-compatible `for` loop.

        This method processes a Kotlin `for` loop that iterates over a range (e.g., `for i in 1..10`) 
        and converts it into its Swift equivalent. It handles the membership expression by calling 
        `check_membership_expression_type()` to ensure the expression is valid and 
        `visit_memebership_expression()` to process the expression. It also checks for valid types, 
        and processes the body of the loop: if the body is a block, it uses `visit_block()`, otherwise, 
        it processes a single statement using `visit_statement()`.

        Args:
            ctx (KotlinParser.ForStatementContext): The context object representing the `for` loop in the 
                                                    Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift equivalent of the Kotlin `for` loop, with the appropriate 
                 expression and body.
        """
        print(f"    üîç Visiting for statement: {ctx.getText()}")
        
        self.check_membership_expression_type(ctx.membershipExpression())
        expression = self.visit_memebership_expression(ctx.membershipExpression())
        if ctx.block(): 
            body = self.visit_block(ctx.block())
        else:  
            body = self.visit_statement(ctx.statement())
        return f"for {expression} {{{body}}}"


    def visit_return_statement(self, ctx: KotlinParser.ReturnStatementContext):
        """
        Converts a Kotlin `return` statement to its Swift equivalent.

        This method processes a Kotlin `return` statement, converting it into a Swift `return` statement. 
        The method checks if the return statement contains an expression by inspecting `ctx.expression()`: 
        if there is an expression, it processes the expression and returns the Swift syntax for returning 
        a value; if no expression is present, it returns a simple `return` statement.

        Args:
            ctx (KotlinParser.ReturnStatementContext): The context object representing the `return` statement 
                                                       in the Kotlin Parse Tree.

        Returns:
            str: A string representing the Swift equivalent of the Kotlin `return` statement, either with 
                 or without an expression.
        """
        print(f"    üîç Visiting return statement: {ctx.getText()}")            
        if ctx.expression():
            expression = self.visit_expression(ctx.expression())
            return f"return {expression}"
        return "return"   


    def visit_expression(self, ctx: KotlinParser.ExpressionContext):
        """
        Transforms a Kotlin expression into its Swift equivalent.

        This method is the entry point for visiting a variety of Kotlin expressions, including literals, 
        identifiers, and operators. It processes the logical OR expressions by delegating the visit to 
        `visit_logical_or_expression()`. 

        Args:
            ctx (KotlinParser.ExpressionContext): The context object representing the expression 
                                                  in the Kotlin Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the given Kotlin expression.
        """
        print(f"    üîç Visiting expression: {ctx.getText()}")
        
        return self.visit_logical_or_expression(ctx.logicalOrExpression())  


    def visit_logical_or_expression(self, ctx: KotlinParser.LogicalOrExpressionContext):
        """
        Transforms a Kotlin logical OR expression into its Swift equivalent.

        This method handles the transformation of Kotlin logical OR expressions (i.e., `a || b`) into Swift. 
        It processes the left and right operands of the logical OR and recursively delegates the handling of
        logical AND expressions to `visit_logical_and_expression()`, as they are building blocks of the 
        logical OR expressions. Operators (i.e., `||`) are placed between operands in the resulting Swift 
        expression.

        Args:
            ctx (KotlinParser.LogicalOrExpressionContext): The context object representing the 
                                                           logical OR expression in the Kotlin 
                                                           Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the logical OR expression.
        """
        print(f"    üîç Visiting logical OR expression: {ctx.getText()}")
        
        left = self.visit_logical_and_expression(ctx.logicalAndExpression(0))
        for i in range(1, len(ctx.logicalAndExpression())):
            operator = ctx.getChild(2 * i - 1).getText()  # The operators are located at position 2i - 1 
            right = self.visit_logical_and_expression(ctx.logicalAndExpression(i))
            left = f"{left} {operator} {right}" if right is not None else f"{left}" 
        return f"{left}"
    

    def visit_logical_and_expression(self, ctx: KotlinParser.LogicalAndExpressionContext):
        """
        Transforms a Kotlin logical AND expression into its Swift equivalent.

        This method handles the transformation of Kotlin logical AND expressions (i.e., `a && b`) into Swift. 
        It processes the left and right operands of the logical AND and recursively delegates the handling of
        equality expressions to `visit_equality_expression()`, as they are building blocks of the logical AND 
        expressions. Operators (i.e., `&&`) are placed between operands in the resulting Swift expression.

        Args:
            ctx (KotlinParser.LogicalAndExpressionContext): The context object representing the 
                                                            logical AND expression in the Kotlin 
                                                            Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the logical AND expression.
        """
        print(f"    üîç Visiting logical AND expression: {ctx.getText()}")
        
        left = self.visit_equality_expression(ctx.equalityExpression(0))  
        for i in range(1, len(ctx.equalityExpression())):
            operator = ctx.getChild(2 * i - 1).getText()  # The operators are located at position 2i - 1 
            right = self.visit_equality_expression(ctx.equalityExpression(i)) 
            left = f"{left} {operator} {right}"
        return f"{left}"


    def visit_equality_expression(self, ctx: KotlinParser.EqualityExpressionContext):
        """
        Transforms a Kotlin equality expression into its Swift equivalent.

        This method handles the transformation of Kotlin equality expressions (i.e., `a == b` or `a != b`) 
        into Swift. It processes the left and right operands of the equality expression and recursively 
        delegates the handling of relational expressions to `visit_relational_expression()`, as they are 
        the building blocks of the equality expression. Operators (i.e., `==` or `!=`) are placed between 
        operands in the resulting Swift expression.

        Args:
            ctx (KotlinParser.EqualityExpressionContext): The context object representing the 
                                                          equality expression in the Kotlin 
                                                          Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the equality expression.
        """
        print(f"    üîç Visiting equality expression: {ctx.getText()}")
        
        left = self.visit_relational_expression(ctx.relationalExpression(0))
        for i in range(1, len(ctx.relationalExpression())):
            operator = ctx.getChild(2 * i - 1).getText()  # The operators are located at position 2i - 1 
            right = self.visit_relational_expression(ctx.relationalExpression(i))  
            left = f"{left} {operator} {right}"  
        return f"{left}"


    def visit_relational_expression(self, ctx: KotlinParser.RelationalExpressionContext):
        """
        Transforms a Kotlin relational expression into its Swift equivalent.

        This method handles the transformation of Kotlin relational expressions (e.g., `a < b`, `a > b`, 
        `a <= b`, `a >= b`) into their Swift equivalents. It processes the left and right operands of the 
        relational expression and delegates the handling of additive expressions (e.g., `a + b`, `a - b`) 
        to `visit_additive_expression()`, as they are the building blocks of the relational expression. 
        Operators (e.g., `<`, `>`, `<=`, `>=`) are placed between operands in the resulting Swift expression.

        Args:
            ctx (KotlinParser.RelationalExpressionContext): The context object representing the 
                                                            relational expression in the Kotlin 
                                                            Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the relational expression.
        """
        print(f"    üîç Visiting relational expression: {ctx.getText()}")
        
        left = self.visit_additive_expression(ctx.additiveExpression(0))
        if len(ctx.additiveExpression()) > 1:
            operator = ctx.getChild(1).getText()  # The operators are located at position 2i - 1 
            right = self.visit_additive_expression(ctx.additiveExpression(1))
            return f"{left} {operator} {right}" 
        return f"{left}"


    def visit_additive_expression(self, ctx: KotlinParser.AdditiveExpressionContext):
        """
        Transforms a Kotlin additive expression into its Swift equivalent.

        This method handles the transformation of Kotlin additive expressions (e.g., `a + b`, `a - b`) 
        into their Swift equivalents. It processes the left and right operands of the additive expression
        and delegates the handling of multiplicative expressions (e.g., `a * b`, `a / b`) to 
        `visit_multiplicative_expression()`, as they are the building blocks of the additive expressions. 
        Operators (e.g., `+`, `-`) are placed between operands in the resulting Swift expression.

        Args:
            ctx (KotlinParser.AdditiveExpressionContext): The context object representing the
                                                          additive expression in the Kotlin     
                                                          Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the additive expression.
        """
        print(f"    üîç Visiting additive expression: {ctx.getText()}")
        
        left = self.visit_multiplicative_expression(ctx.multiplicativeExpression(0))
        for i in range(1, len(ctx.multiplicativeExpression())):
            operator = ctx.getChild(2 * i - 1).getText()  # The operators are located at position 2i - 1 
            right = self.visit_multiplicative_expression(ctx.multiplicativeExpression(i)) 
            left = f"{left} {operator} {right}" 
        return f"{left}"  


    def visit_multiplicative_expression(self, ctx: KotlinParser.MultiplicativeExpressionContext):
        """
        Transforms a Kotlin multiplicative expression into its Swift equivalent.

        This method handles the transformation of Kotlin multiplicative expressions (e.g., `a * b`, `a / b`, 
        `a % b`) into their Swift equivalents. It processes the left and right operands of the 
        multiplicative expression and delegates the handling of unary expressions (e.g., `-a`, `+a`) to 
        `visit_unary_expression()`, as they are the building blocks of the multiplicative expressions. 
        Operators (e.g., `*`, `/`, `%`) are placed between operands in the resulting Swift expression.

        Args:
            ctx (KotlinParser.MultiplicativeExpressionContext): The context object representing the 
                                                                multiplicative expression in the Kotlin 
                                                                Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the multiplicative expression.
        """
        print(f"    üîç Visiting multiplicative expression: {ctx.getText()}")
        
        left = self.visit_unary_expression(ctx.unaryExpression(0))
        for i in range(1, len(ctx.unaryExpression())):
            operator = ctx.getChild(2 * i - 1).getText()  # The operators are located at position 2i - 1 
            right = self.visit_unary_expression(ctx.unaryExpression(i))
            left = f"{left} {operator} {right}" 
        return f"{left}" 


    def visit_unary_expression(self, ctx: KotlinParser.UnaryExpressionContext):
        """
        Transforms a Kotlin unary expression into its Swift equivalent.

        This method handles the transformation of Kotlin unary expressions, such as logical negation (`!a`) 
        and arithmetic negation (`-a`), into their Swift equivalents. It processes the primary expression 
        that follows the unary operator and applies the corresponding Swift unary operator, based on the 
        presence of the `NOT` or `MINUS` token in the context. If the unary expression is neither `!` nor 
        `-`, it delegates the processing of membership expressions to `visit_memebership_expression()`.

        Args:
            ctx (KotlinParser.UnaryExpressionContext): The context object representing the unary expression 
                                                       in the Kotlin Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the unary expression.
        """
        print(f"    üîç Visiting unary expression: {ctx.getText()}")
        
        if ctx.NOT(): 
            return f"!{self.visit_primary_expression(ctx.primaryExpression())}"
        elif ctx.MINUS():
            return f"-{self.visit_primary_expression(ctx.primaryExpression())}"
        else:
            return f"{self.visit_memebership_expression(ctx.membershipExpression())}"


    def visit_memebership_expression(self, ctx: KotlinParser.MembershipExpressionContext):
        """
        Transforms a Kotlin membership expression into its Swift equivalent.

        This method handles the transformation of Kotlin membership expressions, such as checking if 
        a value is in a range, into their Swift equivalents. The method checks if the membership expression
        involves the `in` or `!in` operator and transforms it accordingly. It processes both the left and 
        right sides of the membership expression and applies the appropriate Swift operators. If the 
        `rangeExpression` is present, it is processed and included in the final string.

        Args:
            ctx (KotlinParser.MembershipExpressionContext): The context object representing the 
                                                         membership expression in the Kotlin 
                                                         Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the membership expression.
        """
        print(f"    üîç Visiting membership expression: {ctx.getText()}")
        
        left = self.visit_primary_expression(ctx.primaryExpression())
        if ctx.rangeExpression():
            right = self.visit_range_expression(ctx.rangeExpression())
            if right:   
                if ctx.NOT() and ctx.IN():
                    return f"{left} !in {right}"
                elif ctx.IN():
                    return f"{left} in {right}"
        return f"{left}"
    

    def visit_primary_expression(self, ctx: KotlinParser.PrimaryExpressionContext):
        """
        Transforms a Kotlin primary expression into its Swift equivalent.

        This method handles primary expressions in Kotlin, which can include literals, identifiers, 
        or function call expressions. It processes the context accordingly and generates the 
        appropriate Swift representation. If the primary expression is an identifier, the method 
        returns the identifier name. If the primary expression is a literal or a function call, it 
        recursively processes and transforms those components. Parenthesized expressions are also 
        handled by recursively visiting the enclosed expression.

        Args:
            ctx (KotlinParser.PrimaryExpressionContext): The context object representing the 
                                                         primary expression in the Kotlin 
                                                         Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the primary expression.   
        """
        print(f"    üîç Visiting primary expression: {ctx.getText()}")
        
        if ctx.IDENTIFIER():
            return ctx.IDENTIFIER().getText()              
        elif ctx.LEFT_ROUND_BRACKET() and ctx.RIGHT_ROUND_BRACKET():
            return f"({self.visit_expression(ctx.expression())})"  
        elif ctx.callExpression():
            return self.visit_call_expression(ctx.callExpression())
        elif ctx.literal():
            return self.visit_literal(ctx.literal())


    def visit_range_expression(self, ctx: KotlinParser.RangeExpressionContext):
        """
        Transforms a Kotlin range expression into its Swift equivalent.

        This method handles range expressions in Kotlin, such as `a..b`, and converts them to the 
        corresponding Swift range syntax (e.g., `a ... b`, with three dots for the range). The method 
        expects a valid range expression with two operands (e.g., `a..b`). If an invalid range is 
        encountered (i.e., one of the range bounds is missing), a semantic error is reported.

        Args:
            ctx (KotlinParser.RangeExpressionContext): The context object representing the 
                                                         range expression in the Kotlin 
                                                         Parse Tree.

        Returns:
            str: A string representing the transformed Swift code for the range expression.
        """
        print(f"    üîç Visiting range expression: {ctx.getText()}")
        
        left = self.visit_additive_expression(ctx.additiveExpression(0))
        if not ctx.additiveExpression(1):
            self.semantic_error_listener.semantic_error(
                msg = f"Invalid range found.", 
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return None
        right = self.visit_additive_expression(ctx.additiveExpression(1))        
        return f"{left} ... {right}"


    def visit_call_expression(self, ctx: KotlinParser.CallExpressionContext):
        """
        Transforms a Kotlin function call expression into its Swift equivalent.

        This method handles function calls in Kotlin and converts them into the corresponding Swift 
        function call syntax. If the function call includes arguments, they are transformed into the 
        appropriate Swift call format. If no arguments are provided, the function call will be 
        represented with empty parentheses. If the arguments for the function call are invalid, 
        a semantic error is reported.

        Args:
            ctx (KotlinParser.CallExpressionContext): The context object representing the function 
                                                      call expression in the Kotlin 
                                                      Parse Tree.

        Returns:
            str: A string representing the transformed Swift function call.
        """
        print(f"    üîç Visiting call expression: {ctx.getText()}")
        
        fun_name = self.visit_identifier(ctx.IDENTIFIER())
        
        self.check_call_expression(ctx) 

        if ctx.argumentList():    
            if not self.check_arguments(ctx, fun_name): 
                return None
            arguments = self.visit_argument_list(ctx.argumentList()) 
            return f"{fun_name}({arguments})"
        
        return f"{fun_name}()"
    

    def visit_argument_list(self, ctx: KotlinParser.ArgumentListContext):
        """
        Transforms a list of Kotlin function arguments into Swift-compatible arguments.

        This method processes a list of arguments in a Kotlin function call and converts them 
        into the corresponding Swift syntax, ensuring each argument is properly formatted. 
        The resulting string will contain all arguments joined by commas, as required by Swift 
        function calls.

        Args:
            ctx (KotlinParser.ArgumentListContext): The context object representing the 
                                                    list of function arguments in the Kotlin 
                                                    Parse Tree.

        Returns:
            str: A string representing the transformed Swift arguments, separated by commas.
        """
        print(f"    üîç Visiting argument list: {ctx.getText()}")
        
        return ", ".join([self.visit_argument(argument) for argument in ctx.argument()])
    

    def visit_argument(self, ctx: KotlinParser.ArgumentContext):
        """
        Converts a Kotlin argument into a Swift argument.

        This method processes an individual argument in a Kotlin function call and transforms it 
        into the corresponding Swift argument format, taking into account both named and unnamed 
        arguments. If the argument has an identifier (name), the Swift argument will be in the 
        format `name: value`; if the argument has no name, the Swift argument will just be the value.

        Args:
            ctx (KotlinParser.ArgumentContext): The context object representing a single argument 
                                                in the Kotlin Parse Tree.

        Returns:
            str: A string representing the transformed Swift argument, either as a named argument 
                 (e.g., `name: value`) or just the argument value (e.g., `value`).
        """
        print(f"    üîç Visiting argument: {ctx.getText()}")
        
        argument_value = self.visit_expression(ctx.expression()) 
        if (ctx.IDENTIFIER()):
            argument_name = self.visit_identifier(ctx.IDENTIFIER())
            return f"{argument_name}: {argument_value}"
        return f"{argument_value}"


    def visit_literal(self, ctx: KotlinParser.LiteralContext):
        """
        Handles literal expressions in Kotlin, such as string, integer, or boolean literals.

        This method processes a literal expression in Kotlin and directly returns its string representation.
        The literal can be of various types, including numbers, booleans, or strings. This function does not 
        modify or interpret the literal value but simply returns it as it appears in the Kotlin source code.

        Args:
            ctx (KotlinParser.LiteralContext): The context object representing a literal expression 
                                               in the Kotlin Parse Tree.

        Returns:
            str: The string representation of the literal value in Kotlin, which is directly returned
                 as-is for use in Swift code.
        """
        print(f"    üîç Visiting literal: {ctx.getText()}")
        
        return ctx.getText()


    def visit_comment_statement(self, ctx: KotlinParser.CommentStatementContext):
        """
        Converts Kotlin comments to Swift comments.

        This method processes comment statements in Kotlin and transforms them into their 
        equivalent Swift comment formats. It handles both single-line and block comments.

        Args:
            ctx (KotlinParser.CommentStatementContext): The context object representing a comment
                                                        statement in the Kotlin Parse Tree.

        Returns:
            str: The transformed comment in Swift syntax, either a single-line or block comment.
        """
        print(f"    üîç Visiting comment: {ctx.getText()}")
        if ctx.LINE_COMMENT():
            return self.visit_line_comment(ctx.LINE_COMMENT())
        elif ctx.BLOCK_COMMENT():
            return self.visit_block_comment(ctx.BLOCK_COMMENT())
        else:
            return None
        

    def visit_line_comment(self, ctx: KotlinParser):
        """
        Converts Kotlin inline comments to Swift single-line comments.

        This method processes Kotlin single-line comments (which start with '//' in Kotlin)
        and converts them to Swift single-line comments (which start with '#').

        Args:
            ctx (KotlinParser): The context object representing a single-line comment
                                in the Kotlin Parse Tree.

        Returns:
            str: The transformed comment in Swift syntax, prefixed with '#'.
        """
        print(f"    üîç Visiting inline comment: {ctx.getText()}")
        comment = ctx.getText()[2:].strip() 
        return f"# {comment}"


    def visit_block_comment(self, ctx: KotlinParser):
        """
        Converts Kotlin block comments to Swift block comments.

        This method processes Kotlin block comments (which start with '/*' and end with '*/' in Kotlin)
        and converts them to Swift block comments (which are also enclosed in '/*' and '*/').

        Args:
            ctx (KotlinParser): The context object representing a block comment
                                in the Kotlin Parse Tree.

        Returns:
            str: The transformed comment in Swift syntax, enclosed in '/*' and '*/'.
        """
        print(f"    üîç Visiting block comment: {ctx.getText()}")
        comment = ctx.getText()[2:-2].strip() 
        return f"/* {comment} */" 
    

    ##### SEMANTIC CHECKS #####


    def add_variable_to_symbol_table(self, var_name, type, mutable, value = None):
        """
        Adds a variable to the symbol table with its associated properties.

        This method creates a new `Symbol` object with the specified properties,
        representing the variable, and inserts it into the symbol table. The variable's 
        name, type, mutability, and optional initial value are provided as parameters.

        Args:
            var_name (str): The name of the variable to be added.
            type (str): The type of the variable (e.g., 'Int', 'String').
            mutable (bool): Indicates if the variable is mutable (`True`) or immutable (`False`).
            value (optional): The initial value of the variable. Defaults to `None`.

        Returns:
            None
        """
        print(f"    üîç Adding variable {var_name} to the symbol table.")
        
        symbol = Symbol(name=var_name, type=type, mutable=mutable, value = value)
        self.symbol_table.add_variable(var_name, symbol)


    def check_variable_already_declared(self, ctx, var_name):
        """
        Checks if a variable is already declared in any accessible scope.

        This method verifies whether the specified variable exists in the symbol table. 
        If the variable is not found, it raises a semantic error indicating that the 
        variable is being accessed or assigned before declaration.

        Args:
            ctx: The context object (from the ANTLR parse tree) associated with the statement 
                 where the variable is being used.
            var_name (str): The name of the variable to check.

        Returns:
            bool: `True` if the variable is found in the symbol table; otherwise, `False`.
        """
        print(f"    üîç Checking if variable {var_name} is already declared.")
        
        if not self.symbol_table.lookup_variable(var_name):
            self.semantic_error_listener.semantic_error(
                msg = f"Trying to access or assign variable '{var_name}' before its declaration.", 
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return False
        return True


    def check_variable_already_declared_in_current_scope(self, ctx, var_name):
        """
        Checks if a variable is already declared in the current scope.

        This method ensures that a new variable declaration does not conflict with an 
        existing variable in the same scope. If a conflict is found, a semantic error 
        is reported, indicating that the variable is already declared in the current 
        scope.

        Args:
            ctx: The context object (from the ANTLR parse tree) associated with the statement 
                 where the variable is being declared.
            var_name (str): The name of the variable to check.

        Returns:
            bool: `True` if the variable is already declared in the current scope; 
                  otherwise, `False`.
        """
        print(f"    üîç Checking if variable {var_name} is already declared in the current scope.")
        
        if self.symbol_table.lookup_variable_in_current_scope(var_name):
            self.semantic_error_listener.semantic_error(
                msg = f"Variable '{var_name}' is already declared in the current scope.",
                line = ctx.start.line,
                column = ctx.start.column
            )
            return True
        return False


    def check_variable_already_assigned(self, ctx, var_name):
        """
        Checks if a variable has already been declared and assigned a value.

        This method ensures that a variable is both declared and assigned before it 
        is used. If the variable is not declared, a semantic error is raised through 
        `check_variable_already_declared`, ande the the assignment check is skipped. 
        If it is declared but not assigned, an additional semantic error is reported.

        Args:
            ctx: The context object (from the ANTLR parse tree) associated with the statement 
                 where the variable is being checked.
            var_name (str): The name of the variable to check.

        Returns:
            bool: `True` if the variable is declared and assigned; otherwise, `False`.
        """
        print(f"    üîç Checking if the variable {ctx.getText()} is already assigned.")
        
        if not self.check_variable_already_declared(ctx, var_name): 
            return False
    
        if not self.symbol_table.get_variable_assigned(var_name):
            self.semantic_error_listener.semantic_error(
                msg = f"Variable '{var_name}' is not assigned yet.",
                line = ctx.start.line,
                column = ctx.start.column
            )
            return False
        
        return True
    

    def check_variable_not_assigned(self, ctx, var_name):
        """
        Checks if a variable has already been declared and not assigned a value.

        This method ensures that a variable is declared and not assigned before it 
        is used. If the variable is not declared, a semantic error is raised through 
        `check_variable_already_declared`, ande the the assignment check is skipped. 
        If it is declared and assigned, an additional semantic error is reported.

        Args:
            ctx: The context object (from the ANTLR parse tree) associated with the statement 
                 where the variable is being checked.
            var_name (str): The name of the variable to check.

        Returns:
            bool: `True` if the variable is declared and assigned; otherwise, `False`.
        """
        print(f"    üîç Checking if the variable {ctx.getText()} is already assigned.")
        
        if not self.check_variable_already_declared(ctx, var_name): 
            return False
    
        if self.symbol_table.get_variable_assigned(var_name):
            self.semantic_error_listener.semantic_error(
                msg = f"Variable '{var_name}' is already assigned.",
                line = ctx.start.line,
                column = ctx.start.column
            )
            return False
        
        return True
        
    
    def check_supported_type(self, ctx, type):
        """
        Validates if the given Kotlin type is supported by the transpiler.

        This method checks if the provided type exists within the predefined list of supported
        Kotlin types, which is derived from the `KotlinTypes` enum. If the type is unsupported, 
        a semantic error is raised.

        Args:
            ctx: The context object (from the ANTLR parse tree) where the type is being checked.
            type (str): The Kotlin type to be validated.

        Returns:
            bool: `True` if the type is supported; otherwise, `False`.
        """
        print(f"    üîç Checking if type {type} is supported.")
        
        if type not in [item.value for item in KotlinTypes]:
            self.semantic_error_listener.semantic_error(
                msg = f"Unsupported type '{type}'.",
                line = ctx.start.line,
                column = ctx.start.column
            )
            return False
        return True


    def validate_value(self, ctx, type):
        """
        Validates the value assigned to a variable, ensuring type compatibility.

        This method checks if the type of the value assigned to a variable matches the variable's
        declared type. The `check_expression_type` method is used to determine the type of the 
        expression being assigned. If there is a type mismatch, a semantic error is raised.

        Args:
            ctx: The context object (from the ANTLR parse tree) representing the assignment.
            expected_type (str): The expected type of the variable as declared.

        Returns:
            bool: `True` if the value's type matches the expected type; otherwise, `False`.
        """
        print(f"    üîç Checking if the variable {ctx.getText()} has a valid type.")
        
        value_type = self.check_expression_type(ctx.expression())
        
        if not value_type or type != value_type:
            self.semantic_error_listener.semantic_error(
                msg = f"Type mismatch: Expected type '{type}' but found expression of type '{value_type}'.",
                line = ctx.start.line,
                column = ctx.start.column
            )
            return False

        return True
    
    
    def check_mutability(self, ctx, var_name, is_mutable):
        """
        Validates the mutability of a variable before allowing an assignment.

        This method ensures that an immutable variable (e.g., declared with `val` in Kotlin)
        is not reassigned. If an attempt is made to modify an immutable variable, a semantic
        error is reported.

        Args:
            ctx: The context object (from the ANTLR parse tree) representing the assignment operation.
            var_name (str): The name of the variable being checked.
            is_mutable (bool): Indicates whether the variable is mutable (`True`) or immutable (`False`).

        Returns:
            bool: `True` if the variable is mutable and the assignment is valid; `False` if the variable
                is immutable and the assignment is not allowed.
        """
        print(f"    üîç Checking if the variable {var_name} is mutable.")
                
        if not is_mutable:
            if not self.check_variable_not_assigned(ctx=ctx, var_name=var_name):               
                self.semantic_error_listener.semantic_error(
                    msg = f"Trying to update immutable variable '{var_name}'.", 
                    line = ctx.start.line, 
                    column = ctx.start.column
                )
                return False
        return True
    

    def validate_if_condition(self, ctx):
        """
        Validates the condition in an 'if' statement.

        This method checks whether the condition of an 'if' statement evaluates to a boolean value.
        If the condition does not evaluate to a boolean, a semantic error is raised.

        Args:
            ctx: The context object (from the ANTLR parse tree) representing the 'if' statement.

        Returns:
            bool: `True` if the condition is valid (i.e., evaluates to a boolean); `False` otherwise.
        """
        print(f"    üîç Validating if statement condition.")
        
        condition_type = self.check_expression_type(ctx=ctx.expression())
        if condition_type != KotlinTypes.BOOLEAN.value:
            self.semantic_error_listener.semantic_error(
                msg = f"Invalid expression type in 'if' condition: expected Boolean, found '{condition_type}'.", 
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return False
        return True


    def check_expression_type(self, ctx):
        """
        Determines the type of a given expression by recursively evaluating its components.

        This method evaluates the expression represented in the given context to determine 
        its type. It is the entry point for type-checking all expressions, starting with 
        logical OR expressions.

        Args:
            ctx: The context object (from the ANTLR parse tree) representing the expression.

        Returns:
            str: The type of the expression (e.g., "Int", "Boolean", "String").
        """                
        print(f"    üîç Checking the type of the expression {ctx.getText()}.")
        
        return self.check_logical_or_expression_type(ctx.logicalOrExpression())
    

    def check_logical_or_expression_type(self, ctx):
        """
        Determines the type of a logical OR expression ('||') and validates operand compatibility.

        This method checks whether the operands of the logical OR expression are of type 'Boolean'.
        If the types are incompatible, a semantic error is reported.

        Args:
            ctx: The context object representing the logical OR expression in the ANTLR parse tree.

        Returns:
            str: 'Boolean' or left operand type if the expression is valid; otherwise, 'None'.
        """
        print(f"    üîç Checking the type of the logical or expression {ctx.getText()}.")
        
        left_type = self.check_logical_and_expression_type(ctx.logicalAndExpression(0))

        if(len(ctx.logicalAndExpression()) > 1):
            for i in range(1, len(ctx.logicalAndExpression())):
                right_type = self.check_logical_and_expression_type(ctx.logicalAndExpression(i))
                if right_type != left_type or right_type != KotlinTypes.BOOLEAN.value:
                    self.semantic_error_listener.semantic_error(
                        msg = f"Cannot apply logical or operator to operands of type '{left_type}' and '{right_type}' in expression '{ctx.getText()}'", 
                        line = ctx.start.line, 
                        column = ctx.start.column
                    )
                    return "None"
            return KotlinTypes.BOOLEAN.value            
        return left_type
    

    def check_logical_and_expression_type(self, ctx):
        """
        Determines the type of a logical AND expression ('&&') and validates operand compatibility.

        This method checks whether the operands of the logical AND expression are of type 'Boolean'.
        If the types are incompatible, a semantic error is reported.

        Args:
            ctx: The context object representing the logical AND expression in the ANTLR parse tree.

        Returns:
            str: 'Boolean' or left operand type if the expression is valid; otherwise, 'None'.
        """
        print(f"    üîç Checking the type of the logical and expression {ctx.getText()}.")
        
        left_type = self.check_equality_expression_type(ctx.equalityExpression(0))

        if(len(ctx.equalityExpression()) > 1):
            for i in range(1, len(ctx.equalityExpression())):
                right_type = self.check_equality_expression_type(ctx.equalityExpression(i))
                if right_type != left_type or right_type != KotlinTypes.BOOLEAN.value:                
                    self.semantic_error_listener.semantic_error(
                        msg = f"Cannot apply logical and operator to operands of type '{left_type}' and '{right_type}' in expression '{ctx.getText()}'", 
                        line = ctx.start.line, 
                        column = ctx.start.column
                    )
                    return "None"
            return KotlinTypes.BOOLEAN.value                       
        return left_type
    
    
    def check_equality_expression_type(self, ctx):
        """
        Determines the type of an equality expression ('==' or '!=') and validates operand 
        compatibility.
        
        This method checks whether the operands of the equality expression are of the same type,
        and ensures that the result is of type 'Boolean'.

        Args:
            ctx: The context object representing the equality expression in the ANTLR parse tree.

        Returns:
            str: 'Boolean' or left operand type if the expression is valid; otherwise, 'None'.
        """
        print(f"    üîç Checking the type of the equality expression {ctx.getText()}.")
        
        left_type = self.check_relational_expression_type(ctx.relationalExpression(0))
        
        if(len(ctx.relationalExpression()) > 1):
            for i in range(1, len(ctx.relationalExpression())):
                right_type = self.check_relational_expression_type(ctx.relationalExpression(i))
                if right_type != left_type:
                    self.semantic_error_listener.semantic_error(
                        msg = f"Cannot apply equality operator to operands of type '{left_type}' and '{right_type}' in expression '{ctx.getText()}'", 
                        line = ctx.start.line, 
                        column = ctx.start.column
                    )
                    return "None"
            return KotlinTypes.BOOLEAN.value            
        return left_type
    

    def check_relational_expression_type(self, ctx):
        """
        Determines the type of a relational expression ('<', '<=', '>', '>=') and validates operand 
        compatibility.
        
        This method checks whether the operands of the relational expression are of the same type,
        and ensures that the result is of type 'Boolean'.

        Args:
            ctx: The context object representing the relational expression in the ANTLR parse tree.

        Returns:
            str: 'Boolean' or left operand type if the expression is valid; otherwise, 'None'.
        """
        print(f"    üîç Checking the type of the relational expression {ctx.getText()}.")
        
        left_type = self.check_additive_expression_type(ctx.additiveExpression(0))  
                
        if len(ctx.additiveExpression()) > 1:
            right_type = self.check_additive_expression_type(ctx.additiveExpression(1)) 
            if right_type != left_type or right_type != KotlinTypes.INT.value:
                self.semantic_error_listener.semantic_error(
                    msg = f"Cannot apply relational operator to operands of type '{left_type}' and '{right_type}' in expression '{ctx.getText()}'", 
                    line = ctx.start.line, 
                    column = ctx.start.column
                )
                return "None"
            return KotlinTypes.BOOLEAN.value                     
        return left_type


    def check_additive_expression_type(self, ctx):
        """
        Determines the type of an additive expression ('+' or '-') and validates operand compatibility.
        
        This method checks whether the operands of the additive expression are of the same type,
        and ensures that the result is of type 'Int'.

        Args:
            ctx: The context object representing the additive expression in the ANTLR parse tree.

        Returns:
            str: 'Int' or left operand type if the expression is valid; otherwise, 'None'.
        """
        print(f"    üîç Checking the type of the additive expression {ctx.getText()}.")
        
        left_type = self.check_multiplicative_expression_type(ctx.multiplicativeExpression(0))
        
        if(len(ctx.multiplicativeExpression()) > 1):
            for i in range(1, len(ctx.multiplicativeExpression())):
                right_type = self.check_multiplicative_expression_type(ctx.multiplicativeExpression(i))
                if right_type != left_type or right_type != KotlinTypes.INT.value:
                    self.semantic_error_listener.semantic_error(
                        msg = f"Cannot apply additive operator to operands of type '{left_type}' and '{right_type}' in expression '{ctx.getText()}'", 
                        line = ctx.start.line, 
                        column = ctx.start.column
                    )
                    return "None"
            return KotlinTypes.INT.value
        return left_type

    
    def check_multiplicative_expression_type(self, ctx):
        """
        Determines the type of a multiplicative expression ('*', '/', '%') and validates operand 
        compatibility.
        
        This method checks whether the operands of the multiplicative expression are of the same type,
        and ensures that the result is of type 'Int'.

        Args:
            ctx: The context object representing the multiplicative expression in the ANTLR parse tree.

        Returns:
            str: 'Int' or left operand type if the expression is valid; otherwise, 'None'.
        """
        print(f"    üîç Checking the type of the multiplicative expression {ctx.getText()}.")
        
        left_type = self.check_unary_expression_type(ctx.unaryExpression(0))

        if(len(ctx.unaryExpression()) > 1):
            for i in range(1, len(ctx.unaryExpression())):
                right_type = self.check_unary_expression_type(ctx.unaryExpression(i))
                if right_type != left_type or right_type != KotlinTypes.INT.value:
                    self.semantic_error_listener.semantic_error(
                        msg = f"Cannot apply multiplicative operator to operands of type '{left_type}' and '{right_type}' in expression '{ctx.getText()}'", 
                        line = ctx.start.line, 
                        column = ctx.start.column
                    )
                    return "None"
            return KotlinTypes.INT.value
        return left_type


    def check_unary_expression_type(self, ctx):
        """
        Checks the type of a unary expression, validating the operand's type for unary operators.
        Supports logical NOT and negation (-) operators, along with membership expressions.

        Args:
            ctx: The context representing the unary expression in the ANTLR parse tree.

        Returns:
            str: The type of the expression if valid; otherwise, 'None' if there is a type mismatch.
        """
        print(f"    üîç Checking the type of the unary expression {ctx.getText()}.")
        
        if ctx.NOT(): 
            expr_type = self.check_primary_expression_type(ctx.primaryExpression())  
            if expr_type != KotlinTypes.BOOLEAN.value:
                self.semantic_error_listener.semantic_error(
                    msg = f"Cannot apply operator '{ctx.NOT().getText()}' to operands of type '{expr_type}' in expression '{ctx.getText()}'", 
                    line = ctx.start.line, 
                    column = ctx.start.column
                )
                return "None"
            return expr_type
        elif ctx.MINUS():  
            expr_type = self.check_primary_expression_type(ctx.primaryExpression())  
            if expr_type != KotlinTypes.INT.value:
                self.semantic_error_listener.semantic_error(
                    msg = f"Cannot apply operator '{ctx.MINUS().getText()}' to operands of type '{expr_type}' in expression '{ctx.getText()}'", 
                    line = ctx.start.line, 
                    column = ctx.start.column
                )
                return "None"
            return expr_type
        else:
            return self.check_membership_expression_type(ctx.membershipExpression())


    def check_membership_expression_type(self, ctx):
        """
        Checks the type of a membership expression, such as using the 'in' operator in Kotlin.
        Validates the left-hand side variable and its type, mutability, and range expression.

        Args:
            ctx: The context representing the membership expression in the ANTLR parse tree.

        Returns:
            str: The type of the expression if valid, otherwise returns 'None' for type mismatches.
        """
        print(f"    üîç Checking the type of the membership expression {ctx.getText()}.")
        
        if ctx.rangeExpression():
            if ctx.primaryExpression().IDENTIFIER():
                identifier = ctx.primaryExpression().IDENTIFIER()
                var_name = self.visit_identifier(identifier)
            
                if not self.check_variable_already_declared(ctx, var_name): 
                    return "None"
                elif not self.check_variable_already_assigned(ctx=ctx, var_name=var_name):
                    return "None"
                else:
                    left_type = self.check_primary_expression_type(ctx.primaryExpression())
                    var_type, is_mutable = self.symbol_table.get_variable_info(var_name)
                    if var_type != KotlinTypes.INT.value:
                        self.semantic_error_listener.semantic_error(
                            msg = f"The left-hand side of the 'in' operator must be Int, found {left_type} instead.", 
                            line = ctx.start.line, 
                            column = ctx.start.column
                        )
                        return left_type
                    if is_mutable == False:
                        self.semantic_error_listener.semantic_error(
                            msg = f"The left-hand side of the 'in' operator must be mutable.", 
                            line = ctx.start.line, 
                            column = ctx.start.column
                        )
                        return left_type
                    self.check_range_expression_type(ctx.rangeExpression())
                    return KotlinTypes.BOOLEAN.value 
            else:
                left_type = self.check_primary_expression_type(ctx.primaryExpression())
                self.semantic_error_listener.semantic_error(
                    msg = f"The left-hand side of the 'in' operator must be a variable.", 
                    line = ctx.start.line, 
                    column = ctx.start.column
                )
                return left_type
        else:
            left_type = self.check_primary_expression_type(ctx.primaryExpression())
            return left_type
    

    def check_range_expression_type(self, ctx):
        """
        Checks the types of the range expression (i.e., '..' operator in Kotlin).
        Validates that both the left and right operands are of type 'Int'.

        Args:
            ctx: The context representing the range expression in the ANTLR parse tree.

        Returns:
            str: Returns the type of the left operand if valid, otherwise returns 'None'
                 to indicate type errors.
        """
        print(f"    üîç Checking the type of the range expression {ctx.getText()}.")
        
        left_type = self.check_additive_expression_type(ctx.additiveExpression(0))
        
        if not ctx.additiveExpression(1):
            self.semantic_error_listener.semantic_error(
                msg = f"The for loop requires a range in the iteration condition, but found {left_type}.",
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return "None"

        right_type = self.check_additive_expression_type(ctx.additiveExpression(1))
        
        if left_type != KotlinTypes.INT.value or right_type != KotlinTypes.INT.value:
            self.semantic_error_listener.semantic_error(
                msg = f"The range operator '..' is only supported for Int types, found {left_type} and {right_type} instead.", 
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return "None"
        
        return left_type


    def check_primary_expression_type(self, ctx):
        """
        Checks the type of the primary expression (identifier, literal, function call, 
        or parenthesized expression).
        
        Args:
            ctx: The context representing the primary expression in the ANTLR parse tree.

        Returns:
            str: The type of the expression if valid, otherwise returns 'None' to indicate errors.
        """
        print(f"    üîç Checking the type of the primary expression {ctx.getText()}.")
        
        if ctx.IDENTIFIER():
            identifier = self.visit_identifier(ctx.IDENTIFIER())        
            if not self.check_variable_already_declared(ctx=ctx, var_name=identifier):        
                return "None"

            if not self.check_variable_already_assigned(ctx=ctx, var_name=identifier):
                return "None"
            
            var_type, _ = self.symbol_table.get_variable_info(identifier)
            return var_type
        elif ctx.LEFT_ROUND_BRACKET() and ctx.RIGHT_ROUND_BRACKET():
            return self.check_expression_type(ctx=ctx.expression())
        elif ctx.literal():
            return self.check_literal_type(ctx=ctx.literal())
        elif ctx.callExpression():
            return self.check_call_expression(ctx.callExpression())
        else:
            self.semantic_error_listener.semantic_error(
                msg = f"Unsupported expression type for expression '{ctx.getText()}'.", 
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return "None"


    def check_literal_type(self, ctx):
        """
        Checks the type of the literal expression (e.g., Int, String, Boolean, etc.).
        
        Args:
            ctx: The context representing the literal in the ANTLR parse tree.

        Returns:
            str: The type of the literal expression if valid, otherwise returns 'None' 
                 to indicate errors.
        """
        print(f"    üîç Checking the type of the literal expression {ctx.getText()}.")
        
        literal = ctx.getText()
        if literal.isdigit():
            return KotlinTypes.INT.value
        elif literal.startswith('"') and literal.endswith('"'): 
            return KotlinTypes.STRING.value
        elif literal == 'true' or literal == 'false':
            return KotlinTypes.BOOLEAN.value
        else:
            self.semantic_error_listener.semantic_error(
                msg = f"Unsupported expression type for variable '{literal}'.", 
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return "None"


    def check_parameter_type_list(self, ctx):
        """
        Checks the types of a list of parameters and returns a comma-separated string 
        of valid types.

        Args:
            ctx: The context representing the parameter list in the ANTLR parse tree.

        Returns:
            str: A comma-separated list of parameter types if valid, otherwise returns None 
                 to indicate errors.
        """
        print(f"    üîç Checking the type of the parameters list {ctx.getText()}.")
        
        return ", ".join([self.check_parameter_type(param) for param in ctx.parameter() if self.check_parameter_type(param) is not None])


    def check_parameter_type(self, ctx):      
        """
        Checks the type of a single parameter and validates if the type is supported.
        
        Args:
            ctx: The context representing the parameter in the ANTLR parse tree.
        
        Returns:
            str: The parameter type if supported, otherwise None.
        """
        print(f"    üîç Checking the type of the parameter {ctx.getText()}.")  
        
        kotlin_param_type = ctx.type_().getText()
        if not self.check_supported_type(ctx=ctx, type=kotlin_param_type):
            return None
        return kotlin_param_type
    
    
    def check_duplicate_parameters(self, ctx, fun_name):
        """
        Checks if a function has duplicate parameters.

        Args:
            ctx: The context representing the function declaration in the ANTLR parse tree.
            fun_name: The name of the function being checked.
        
        Returns:
            bool: True if no duplicates are found, False otherwise.
        """
        print(f"    üîç Checking for duplicate parameters in function {fun_name}.")
        
        parameter_list = [param.strip() for param in self.check_parameter_name_list(ctx).split(", ")]
        params_seen = set() # non-duplicated params
        duplicate_params = []

        for param in parameter_list:
            if param in params_seen:
                duplicate_params.append(param)
            else:
                params_seen.add(param)
        if duplicate_params:
            duplicates = ", ".join(duplicate_params)
            self.semantic_error_listener.semantic_error(
                msg = f"Function '{fun_name}' has duplicate parameters: {duplicates}.",
                line = ctx.start.line,
                column = ctx.start.column,
            )
            return False

        return True


    def check_parameter_name_list(self, ctx):
        """
        Checks and returns the list of parameter names from the function's parameter list.

        Args:
            ctx: The context representing the function declaration in the ANTLR parse tree.
        
        Returns:
            str: A comma-separated list of parameter names. 
        """
        print(f"    üîç Checking the name of the parameters list {ctx.getText()}.")
        
        return ", ".join([self.check_parameter_name(param) for param in ctx.parameter()])


    def check_parameter_name(self, ctx):    
        """
        Checks the name of the parameter and returns the parameter name.
        
        Args:
            ctx: The context representing a parameter in the ANTLR parse tree.
        
        Returns:
            str: The parameter name.
        """
        print(f"    üîç Checking the name of the parameter {ctx.getText()}.")
        
        param_name = self.visit_identifier(ctx.IDENTIFIER())
        return param_name
    

    def check_parameter_name_value_list(self, ctx):
        """
        Checks the value of the parameters list and returns a comma-separated string 
        of valid parameter names and values.
        
        Args:
            ctx: The context representing a list of parameters in the ANTLR parse tree.
        
        Returns:
            str: A comma-separated list of valid parameter names and values.
        """
        print(f"    üîç Checking the value of the parameters list {ctx.getText()}.")
        
        return ", ".join([self.check_parameter_name_value(param) for param in ctx.parameter() if self.check_parameter_name_value(param) is not None])


    def check_parameter_name_value(self, ctx):   
        """
        Checks and returns the name and value of the parameter, 
        formatted as 'name: value'. If no value is provided, it returns 
        'name: None'.
        
        Args:
            ctx: The context representing the parameter in the ANTLR parse tree.
        
        Returns:
            str: A formatted string representing the parameter name and its value.
        """
        print(f"    üîç Checking the value of the parameter {ctx.getText()}.")    
        
        param_name = self.visit_identifier(ctx.IDENTIFIER())
        param_value = self.visit_expression(ctx.expression()) if (ctx.expression()) else None 
        return f"{param_name}: {param_value}"
    

    def check_function_not_declared_in_current_scope(self, ctx, fun_name, argument_types):
        """
        Checks if a function is called before its declaration in the current scope.
        
        Args:
            ctx: The context of the function call.
            fun_name: The name of the function being called.
            argument_types: A list of argument types used in the function call.

        Returns:
            bool: True if the function is not declared in the current scope, False otherwise.
        """
        print(f"    üîç Checking if function {fun_name} is not declared in currrent scope.")
        
        if not self.symbol_table.lookup_function(fun_name, argument_types):
            self.semantic_error_listener.semantic_error(
                msg = f"Trying to call function '{fun_name}' with signature '{argument_types}' before its declaration." if argument_types 
                        else f"Trying to call function '{fun_name}' before its declaration.", 
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return True
        return False


    def check_function_already_declared_in_current_scope(self, ctx, fun_name, kotlin_param_types):
        """
        Checks if a function with the given name and parameter types is already declared in the 
        current scope.

        Args:
            ctx: The context of the function declaration or call.
            fun_name: The name of the function.
            kotlin_param_types: The list of parameter types for the function.

        Returns:
            bool: True if the function is already declared in the current scope, False otherwise.
        """
        print(f"    üîç Checking if function {fun_name} is already declared in currrent scope.")
        
        if self.symbol_table.lookup_function(fun_name, kotlin_param_types):
            self.semantic_error_listener.semantic_error(
                msg = f"Function '{fun_name}' with signature '{kotlin_param_types}' is already declared in the current scope." if kotlin_param_types
                        else f"Function '{fun_name}' is already declared in the current scope.", 
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return True
        return False
        

    def check_call_expression(self, ctx):
        """
        Checks that a function call is properly declared and matches the expected signature. It 
        retrieves the function name and arguments from the context, verifies the function's existence 
        and signature, and determines its return type.
        
        Args:
            ctx: Parser context for the function call.

        Returns:
            str: The function's return type if valid; "None" otherwise.

        Steps:
            1. Extracts the function name and argument types.
            2. Checks if the function is declared with the correct signature.
            3. Returns the function's return type or logs an error if undefined.
        """
        print(f"    üîç Checking call expression {ctx.getText()}.")
        
        fun_name = ctx.IDENTIFIER().getText()
        argument_types = self.check_argument_type_list(ctx.argumentList()) if ctx.argumentList() else None

        if self.check_function_not_declared_in_current_scope(ctx, fun_name, argument_types):
            return "None"
        
        return_type = self.symbol_table.get_function_return_type(fun_name, argument_types)        
        
        return return_type
    
    
    def check_argument_type_list(self, ctx):
        """
        Checks the types of the arguments in a function call expression.

        This method iterates over the arguments in the function call and checks the type of each argument 
        using the `check_argument_type` method. It returns a comma-separated list of argument types.

        Args:
            ctx: The context of the argument list in the function call expression.

        Returns:
            str: A comma-separated list of argument types for the function call.
        """
        print(f"    üîç Checking the type of the arguments list {ctx.getText()}.")
        
        return ", ".join([self.check_argument_type(argument) for argument in ctx.argument()])       
    

    def check_argument_type(self, ctx):
        """
        Checks the type of a single argument in a function call.

        This method evaluates the type of the argument by checking the type of its expression 
        using the `check_expression_type` method. It returns the type of the argument.

        Args:
            ctx: The context of the argument in the function call expression.

        Returns:
            str: The type of the argument.
        """
        print(f"    üîç Checking the type of the argument {ctx.getText()}.")
        
        return self.check_expression_type(ctx.expression())


    def check_argument_name_list(self, ctx):
        """
        Checks the names of the arguments in a function call.

        This method retrieves and checks the names of all the arguments in the list of arguments 
        passed to a function call. It returns a string with the names of all arguments, separated 
        by commas.

        Args:
            ctx: The context of the argument list in the function call expression.

        Returns:
            str: A comma-separated list of the argument names.
        """
        print(f"    üîç Checking the name of the arguments list {ctx.getText()}.")
        
        return ", ".join([self.check_argument_name(argument) for argument in ctx.argument()])       
    

    def check_argument_name(self, ctx):
        """
        Checks the name of an individual argument in a function call.

        This method retrieves the name of a single argument passed to a function call.
        It returns the argument's name as a string.

        Args:
            ctx: The context of the argument in the function call expression.

        Returns:
            str: The name of the argument, or "None" if no identifier is found.
        """
        print(f"    üîç Checking the name of the argument {ctx.getText()}.")
        
        argument_name = self.visit_identifier(ctx.IDENTIFIER()) if (ctx.IDENTIFIER()) else "None"
        return argument_name


    def check_return_statement(self, ctx, fun_name, fun_return_type):
        """
        Checks if a function has a valid return statement based on its return type.

        This method ensures that:
        1. Functions with a return type include a return statement.
        2. Functions without a return type do not include a return statement.
        3. It validates that the return statement, if present, matches the expected return type.

        It also recursively checks for return statements in nested structures like 
        `for` loops and `if` statements.

        Args:
            ctx: The context representing the function body in the Parse Tree..
            fun_name: The name of the function being checked.
            fun_return_type: The expected return type of the function (or `None` if no return type).

        Returns:
            bool: `True` if the return statement is valid, `False` otherwise.
        """
        print(f"    üîç Checking the return statement of the function {fun_name}.")
        
        # Iterate over all statements in the function body and check for return statements
        if fun_return_type:
            if not ctx.statement():
                # If no return statement is found and a return type is expected
                self.semantic_error_listener.semantic_error(
                    msg = f"Function '{fun_name}' must have a return statement.", 
                    line = ctx.start.line, 
                    column = ctx.start.column
                )
                return False
            else:      
                valid_return_stmt = False
                valid_return_stmt_in_for = False
                valid_return_stmt_in_if_else = False
                
                for stmt in ctx.statement():
                    if stmt.returnStatement():
                        return_stmt = stmt.returnStatement()
                        valid_return_stmt = self.validate_return_statement(return_stmt, fun_name, fun_return_type) 
                    if stmt.forStatement():
                        for_stmt = stmt.forStatement()
                        valid_return_stmt_in_for = self.check_return_statement_in_for_statement(for_stmt, fun_name, fun_return_type) 
                    if stmt.ifElseStatement():
                        if_stmt = stmt.ifElseStatement()
                        valid_return_stmt_in_if_else = self.check_return_statement_in_if_else_statement(if_stmt, fun_name, fun_return_type) 
                
                if valid_return_stmt or valid_return_stmt_in_for or valid_return_stmt_in_if_else:
                    return True
                else:
                    # Return statement not valid
                    self.semantic_error_listener.semantic_error(
                        msg = f"Function '{fun_name}' must have a valid return statement.", 
                        line = ctx.start.line, 
                        column = ctx.start.column
                    )
                    return False
        else:
            no_return_stmt = True
            no_return_stmt_in_for = True
            no__return_stmt_in_if_else = True
    
            for stmt in ctx.statement():
                if stmt.returnStatement():
                    self.semantic_error_listener.semantic_error(
                        msg = f"Function '{fun_name}' has no return type, but includes a return statement.", 
                        line = ctx.start.line,  
                        column = ctx.start.column
                    )
                    no_return_stmt = False
                if stmt.forStatement():
                    for_stmt = stmt.forStatement()
                    no_return_stmt_in_for = self.check_no_return_statement_in_for_statement(for_stmt, fun_name)
                if stmt.ifElseStatement():
                    if_stmt = stmt.ifElseStatement()
                    no__return_stmt_in_if_else = self.check_no_return_statement_in_if_else_statement(if_stmt, fun_name)
            
            return no_return_stmt and no_return_stmt_in_for and no__return_stmt_in_if_else 
    

    def check_return_statement_in_for_statement(self, ctx, fun_name, fun_return_type):
        """
        Checks if a return statement is properly handled inside a `for` loop in a function.

        This method ensures that the return statement, if present, matches to the function's
        return type expected.

        Args:
            ctx: The context representing the `for` loop in the Parse Tree.
            fun_name: The name of the function being checked.
            fun_return_type: The expected return type of the function (or `None` if no return type).

        Returns:
            bool: `True` if the return statement within the `for` loop is valid, `False` otherwise.
        """
        print(f"    üîç Checking the return statement of the function {fun_name} in for statement.")
        
        if ctx.block(): 
            block = ctx.block()
            for stmt in block.statement():
                if stmt.returnStatement():
                    return_stmt = stmt.returnStatement()
                    return self.validate_return_statement(return_stmt, fun_name, fun_return_type) 
        else:  
            stmt = ctx.statement()
            if stmt.returnStatement():
                return_stmt = stmt.returnStatement()
                return self.validate_return_statement(return_stmt, fun_name, fun_return_type) 
            
    
    def check_return_statement_in_if_else_statement(self, ctx, fun_name, fun_return_type):
        """
        Checks if a return statement is properly handled inside an `if-else` statement in a function.

        This method ensures that:
        1. The return statement is validated in the `if` branch.
        2. If an `else` branch exists, the return statement is validated in the `else` branch too.
        3. The return statement(s) in both branches, if present, matches to the function's expected 
        return type.

        Args:
            ctx: The context representing the `if-else` statement in the Parse Tree.
            fun_name: The name of the function being checked.
            fun_return_type: The expected return type of the function (or `None` if no return type).

        Returns:
            bool: `True` if all return statements in the `if` and `else` branches are valid, 
                  `False` otherwise.
        """
        print(f"    üîç Checking the return statement of the function {fun_name} in if-else statement.")
        
        if_body = ctx.ifBody()
        check_if = self.check_return_statement_in_if_else_body(if_body, fun_name, fun_return_type)

        if ctx.ELSE():
            else_body = ctx.elseBody()
            check_else = self.check_return_statement_in_if_else_body(else_body, fun_name, fun_return_type)
            return check_if and check_else
        
        return check_if


    def check_return_statement_in_if_else_body(self, ctx, fun_name, fun_return_type):
        """
        Checks if a return statement is properly handled inside the body of an `if` or `else` statement.

        This method ensures that:
        1. The return statement is validated inside the `if` or `else` body.
        2. If no return statement is found in the body, an error is raised indicating the function must 
        have a return statement.

        Args:
            ctx: The context representing the body of the `if` or `else` statement in the Parse Tree.
            fun_name: The name of the function being checked.
            fun_return_type: The expected return type of the function (or `None` if no return type).

        Returns:
            bool: `True` if a valid return statement is found in the body, 
                  `False` if no return statement is found and an error is raised.
        """
        print(f"    üîç Checking the return statement of the function {fun_name} in if-else body.")
        
        if ctx.block(): 
            block = ctx.block()
            for stmt in block.statement():
                if stmt.returnStatement():
                    return_stmt = stmt.returnStatement()
                    return self.validate_return_statement(return_stmt, fun_name, fun_return_type)
        else:  
            stmt = ctx.statement()
            if stmt.returnStatement():
                return_stmt = stmt.returnStatement()
                return self.validate_return_statement(return_stmt, fun_name, fun_return_type) 
        
        return False


    def check_no_return_statement_in_for_statement(self, ctx, fun_name):
        """
        Ensures that a function without a return type does not contain any return statements 
        within a `for` loop.

        This method checks whether a `for` loop contains any return statements in the function's 
        body. If a return statement is found in a function that does not have a return type, 
        it raises an error.

        Args:
            ctx: The context representing the `for` loop statement in the Parse Tree.
            fun_name: The name of the function being checked.

        Returns:
            bool: `True` if no return statement is found in the `for` loop (or it is correctly handled), 
                  `False` if a return statement is found and an error is raised.
        """
        print(f"    üîç Checking missing return statement of the function {fun_name} in for statement.")
        
        if ctx.block(): 
            block = ctx.block()
            for stmt in block.statement():
                if stmt.returnStatement():
                    self.semantic_error_listener.semantic_error(
                        msg = f"Function '{fun_name}' has no return type, but includes a return statement.", 
                        line = ctx.start.line,  
                        column = ctx.start.column
                    )
                    return False
        else:  
            stmt = ctx.statement()
            if stmt.returnStatement():
                    self.semantic_error_listener.semantic_error(
                        msg = f"Function '{fun_name}' has no return type, but includes a return statement.", 
                        line = ctx.start.line,  
                        column = ctx.start.column
                    )
                    return False
        return True  


    def check_no_return_statement_in_if_else_statement(self, ctx, fun_name): 
        """
        Ensures that a function without a return type does not contain any return statements 
        within an `if-else` statement.

        This method checks whether the `if` and `else` blocks within an `if-else` statement contain 
        any return statements. If a return statement is found in a function that does not have a 
        return type, it raises an error.

        Args:
            ctx: The context representing the `if-else` statement in the Parse Tree.
            fun_name: The name of the function being checked.

        Returns:
            bool: `True` if no return statement is found in the `if` and `else` bodies (or it is 
                  correctly handled), `False` if a return statement is found and an error is raised.
        """
        print(f"    üîç Checking missing return statement of the function {fun_name} in if-else statement.")
        
        if_body = ctx.ifBody()
        check_if = self.check_no_return_statement_in_if_else_body(if_body, fun_name)

        if ctx.ELSE():
            else_body = ctx.elseBody()
            check_else = self.check_no_return_statement_in_if_else_body(else_body, fun_name)
            return check_if and check_else
        
        return check_if 


    def check_no_return_statement_in_if_else_body(self, ctx, fun_name):
        """
        Ensures that a function without a return type does not contain any return statements within 
        the body of an `if-else` statement.

        This method checks whether any `return` statements are present within the `if` or `else` body. 
        If a return statement is found in a function that does not have a return type, it raises an error.

        Args:
            ctx: The context representing the body of the `if-else` statement in the Parse Tree.
            fun_name: The name of the function being checked.

        Returns:
            bool: `True` if no return statement is found (or correctly handled), 
                `False` if a return statement is found and an error is raised.
        """
        print(f"    üîç Checking missing return statement of the function {fun_name} in if-else body.")
        
        if ctx.block(): 
            block = ctx.block()
            for stmt in block.statement():
                if stmt.returnStatement():
                    self.semantic_error_listener.semantic_error(
                        msg = f"Function '{fun_name}' has no return type, but includes a return statement.", 
                        line = ctx.start.line,  
                        column = ctx.start.column
                    )
                    return False
        else:  
            stmt = ctx.statement()
            if stmt.returnStatement():
                self.semantic_error_listener.semantic_error(
                    msg = f"Function '{fun_name}' has no return type, but includes a return statement.", 
                    line = ctx.start.line,  
                    column = ctx.start.column
                )
                return False
        return True  


    def validate_return_statement(self, ctx, fun_name, fun_return_type):
        """
        Validates the return statement of a function to ensure type correctness.

        This method checks if the return statement has an expression and if the type of the returned 
        value matches the declared return type of the function. If there is a type mismatch or if the 
        return statement does not include an expression, an error is raised.

        Args:
            ctx: The context representing the return statement in the Parse Tree.
            fun_name: The name of the function being checked.
            fun_return_type: The declared return type of the function.

        Returns:
            bool: `True` if the return statement is valid, `False` if an error is found (either due to 
                  a type mismatch or a missing return expression).
        """
        print(f"    üîç Validating return statement of the function {fun_name}.")
        
        return_expression = ctx.expression()
        if return_expression:
            if not self.validate_value(ctx=ctx, type=fun_return_type):
                actual_return_type = self.check_expression_type(return_expression)
                self.semantic_error_listener.semantic_error(
                    msg = f"Return type mismatch: Function '{fun_name}' is declared to return type '{fun_return_type}', but the actual return type is '{actual_return_type}'.", 
                    line = ctx.start.line, 
                    column = ctx.start.column
                )
                return False
        else:
            # Found a return statement without any expression
            self.semantic_error_listener.semantic_error(
                msg = f"Function '{fun_name}' must have a return statement of type {fun_return_type}.", 
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return False
        return True  
    

    def check_arguments(self, ctx, fun_name):
        """
        Checks the validity of the arguments for a function by verifying both their types and names.

        This method checks if the arguments of the function match the expected types and names. 

        Args:
            ctx: The context representing the arguments in the Parse Tree.
            fun_name: The name of the function whose arguments are being checked.

        Returns:
            bool: `True` if both argument types and names are valid, `False` if any issue is found.
        """
        print(f"    üîç Checking arguments of function {fun_name}.")
        
        return (self.check_argument_types(ctx, fun_name) and self.check_argument_names(ctx, fun_name))


    def check_argument_types(self, ctx, fun_name):
        """
        Checks if the argument types in the function call match the expected parameter types 
        for that function.
        
        This method verifies that the argument types align with one of the valid function signatures 
        defined in the current scope. If no matching signature is found or if the argument types are 
        incorrect, an error is raised.

        Args:
            ctx: The context representing the function call and its argument list in the Parse Tree.
            fun_name: The name of the function being called.

        Returns:
            bool: `True` if the argument types match a declared function signature, `False` otherwise.
        """
        print(f"    üîç Checking types of arguments of the function {fun_name}.")
        
        argument_types = self.check_argument_type_list(ctx.argumentList()) 
        
        if self.check_function_not_declared_in_current_scope(ctx = ctx, fun_name = fun_name, argument_types=argument_types):        
            return False
        function_versions = self.symbol_table.get_function_params(fun_name)
        
        if not function_versions:
            self.semantic_error_listener.semantic_error(
                msg = f"Function '{fun_name}' with argument types {argument_types} is not declared in any scope.",
                line = ctx.start.line,
                column = ctx.start.column,
            )
            return False            
        
        # Check if there is a version of the function that matches the provided arguments
        for fun in function_versions:
            param_types = fun["param_types"]
            
            # Check if the number of parameters matches
            if len(param_types) != len(argument_types):
                continue  # They don't match, try the next version of the function

            # Check if the parameter types match
            match = True
            for param_type, arg_type in zip(param_types, argument_types):
                if param_type != arg_type:
                    match = False
                    break
            
            if match:
                return True  # Found a match

        # If no matches are found
        self.semantic_error_listener.semantic_error(
            msg = f"Function '{fun_name}' with argument types {argument_types} does not match any signature in the current scope.",
            line = ctx.start.line,
            column = ctx.start.column,
        )
        return False 
 

    def check_argument_names(self, ctx, fun_name):
        """
        Checks if the argument names in the function call match the expected parameter names 
        for that function.

        This method verifies that the argument names match to one of the valid function signatures 
        defined in the current scope. If no matching signature is found or if the argument names are 
        incorrect, an error is raised.

        Args:
            ctx: The context representing the function call and its argument list in the Parse Tree.
            fun_name: The name of the function being called.

        Returns:
            bool: `True` if the argument names match a declared function signature, `False` otherwise.
        """
        print(f"    üîç Checking names of arguments of the function {fun_name}.")
        
        argument_names = self.check_argument_name_list(ctx.argumentList())
        argument_names_list = argument_names.split(", ")

        function_versions = self.symbol_table.get_function_params(fun_name)    

        if not function_versions:
            self.semantic_error_listener.semantic_error(
                msg = f"Function '{fun_name}' with argument names {argument_names} is not declared in any scope.",
                line = ctx.start.line,
                column = ctx.start.column,
            )
            return False            

        # Check if there is a version of the function that matches the provided argument names
        for fun in function_versions:

            param_names = fun["param_names"]  # Assuming you have stored parameter names in the function definitions
            param_names_list = param_names.split(", ")

            # Check if the number of parameters matches
            if len(param_names_list) != len(argument_names_list):
                continue  # They don't match, try the next version of the function
            
            # Check if the parameter names match
            match = True

            for param_name, arg_name in zip(param_names_list, argument_names_list):
                if arg_name != "None" and param_name != arg_name:
                    match = False
                    break
            
            if match:
                return True  # Found a match
        
        # If no matches are found
        self.semantic_error_listener.semantic_error(
            msg = f"Function '{fun_name}' with argument names {argument_names} does not match any signature in the current scope.",
            line = ctx.start.line,
            column = ctx.start.column,
        )
        return False


    def check_class_already_declared_in_current_scope(self, ctx, class_name):
        """
        Checks if a class with the given name is already declared in the current scope.

        This method verifies whether a class has already been declared in the current scope 
        (e.g., in the same file). If the class is already declared, it raises a semantic error 
        indicating that the class name is already in use.

        Args:
            ctx: The context of the class declaration in the Parse Tree, which contains information about 
                 the line and column.
            class_name: The name of the class to check for in the current scope.

        Returns:
            bool: `True` if the class is already declared in the current scope, `False` otherwise.
        """
        print(f"    üîç Checking if class {class_name} is already declared in the current scope.")
        
        if self.symbol_table.lookup_class(class_name):
            self.semantic_error_listener.semantic_error(
                msg = f"Class '{class_name}' is already declared in the current scope.",
                line = ctx.start.line, 
                column = ctx.start.column
            )
            return True
        return False
    